/*
 * Copyright (c) 2017 by Evernote Corporation, All rights reserved.
 *
 * Use of the source code and binary libraries included in this package
 * is permitted under the following terms:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "ENTProtocol.h"
#import "ENTException.h"
#import "FATObject.h"
#import "EDAMUserStore.h"
#import "EDAMTypes.h"
#import "EDAMErrors.h"
#import "EDAMLimits.h"

enum EDAMUserSetting {
  UserSetting_RECEIVE_REMINDER_EMAIL = 1,
  UserSetting_TIMEZONE = 2
};

enum EDAMShareRelationshipPrivilegeLevel {
  ShareRelationshipPrivilegeLevel_READ_NOTEBOOK = 0,
  ShareRelationshipPrivilegeLevel_READ_NOTEBOOK_PLUS_ACTIVITY = 10,
  ShareRelationshipPrivilegeLevel_MODIFY_NOTEBOOK_PLUS_ACTIVITY = 20,
  ShareRelationshipPrivilegeLevel_FULL_ACCESS = 30
};

enum EDAMSearchScope {
  SearchScope_PERSONAL = 0,
  SearchScope_BUSINESS = 1
};

/*
 * <p>When obtaining SyncState, an instance of this structure may be
 * present to provide guidance for how long to wait in between
 * various service method calls to the service. These values are
 * defined for/scoped to a given account and you should manage sync
 * accordingly.  At the end of the day, clients are synchronizing the
 * data from a given account even if they need to make multiple calls
 * to service with different values.  You should not mix up values for
 * different accounts! For example, you should definitely not use the
 * values obtained from your personal account as the rates for your
 * business as this could impact service stability.</p>
 * 
 * <p> Note that you may get values for various service methods that
 * return different SyncState.clientSyncRateConfig values for the same
 * account.  For example, synchronizing from a friend's personal
 * account could involve multiple calls to getLinkedNotebookSyncState
 * and the different calls could return different values, but you
 * should NOT stop in the middle of sync for that account and should,
 * rather, complete any in-progress sync of that account while
 * remembering the latest values for the next round of sync.<p/>
 * 
 * <dl>
 * <dt>syncStateIntervalMillis</dt>
 *   <dd>This is the recommended interval, in milliseconds, between
 *   calls to getSyncState or getLinkedNotebookSyncState for the
 *   account.  This field will always be present.
 *   </dd>
 * <dt>updateNoteWhenIdleForMillis</dt>
 *   <dd>If present, the number of milliseconds to wait before a dirty
 *   note that was being edited is declared idle and should be updated
 *   on the service.
 *   </dd>
 * <dt>updateNoteDuringEditIntervalMillis</dt>
 *   <dd>If present, the number of milliseconds to wait, while a note
 *   is being actively edited, before we should update it on the
 *   service.
 *   </dd>
 * </dl>
 */
@interface EDAMClientSyncRateConfig : FATObject 
@property (nonatomic, strong) NSNumber * syncStateIntervalMillis; // int64_t
@property (nonatomic, strong) NSNumber * updateNoteWhenIdleForMillis; // int64_t
@property (nonatomic, strong) NSNumber * updateNoteDuringEditIntervalMillis; // int64_t
@end

/*
 * This structure encapsulates the information about the state of the
 * user's account for the purpose of "state based" synchronization.
 * <dl>
 * <dt>currentTime</dt>
 *   <dd>
 *   The server's current date and time.
 *   </dd>
 * <dt>fullSyncBefore</dt>
 *   <dd>
 *   The cutoff date and time for client caches to be
 *   updated via incremental synchronization.  Any clients that were last
 *   synched with the server before this date/time must do a full resync of all
 *   objects.  This cutoff point will change over time as archival data is
 *   deleted or special circumstances on the service require resynchronization.
 *   </dd>
 * <dt>updateCount</dt>
 *   <dd>
 *   Indicates the total number of transactions that have
 *   been committed within the account.  This reflects (for example) the
 *   number of discrete additions or modifications that have been made to
 *   the data in this account (tags, notes, resources, etc.).
 *   This number is the "high water mark" for Update Sequence Numbers (USN)
 *   within the account.
 *   </dd>
 * <dt>uploaded</dt>
 *   <dd>
 *   The total number of bytes that have been uploaded to
 *   this account in the current monthly period.  This can be compared against
 *   Accounting.uploadLimit (from the UserStore) to determine how close the user
 *   is to their monthly upload limit.
 *   This value may not be present if the SyncState has been retrieved by
 *   a caller that only has read access to the account.
 *   </dd>
 * <dt>userLastUpdated</dt>
 *   <dd>
 *   The last time when a user's account level information was changed. This value
 *   is the latest time when a modification was made to any of the following:
 *   accounting information (billing, quota, premium status, etc.), user attributes
 *   and business user information (business name, business user attributes, etc.) if
 *   the user is in a business.
 *   Clients who need to maintain account information about a User should watch this
 *   field for updates rather than polling UserStore.getUser for updates. Here is the
 *   basic flow that clients should follow:
 *   <ol>
 *     <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
 *     <li>Compare SyncState.userLastUpdated to previously stored value:
 *         if (SyncState.userLastUpdated > previousValue)
 *           call UserStore.getUser to get the latest User object;
 *         else
 *           do nothing;</li>
 *     <li>Update previousValue = SyncState.userLastUpdated</li>
 *   </ol>
 *   </dd>
 * <dt>userMaxMessageEventId</dt>
 *   <dd>
 *   The greatest MessageEventID for this user's account. Clients that do a full
 *   sync should store this value locally and compare their local copy to the
 *   value returned by getSyncState to determine if they need to sync with
 *   MessageStore. This value will be omitted if the user has never sent or
 *   received a message.
 *   </dd>
 * <dt>businessSummaryUpdated</dt>
 *   <dd>
 *   The date when the user's Business Summary recommendations were last
 *   updated. This is set only if the SyncState being requested is for a
 *   user who is currently a member of a business and has had business
 *   summary recommendations generated at least once. It is not set for calls
 *   made using a business authentication token. Depending on server-side
 *   cache status it may occasionally be unset even if these criteria are met.
 *   The Business Summary should be fetched by clients only if the date
 *   reported here is later than than the date of the last fetch. INTERNAL
 *   ONLY!
 *   </dd>
 * <dt>communicationEngineUpdateId</dt>
 *   <dd>
 *   A sequence number for the current user's CommunicationEngine state. Clients
 *   should pass this to the CommunicationsEngine client which will take care of
 *   interpreting the value and persisting it if necessary. This value may be
 *   omitted if the user has never had any messages targeted to them.
 *   </dd>
 * <dt>currentDevicesUsed</dt>
 *   <dd>
 *   The number of devices the user currently has signed into that counts against
 *   their maximum device limit. This combined with AccountLimits.devicesLimit can
 *   be used to determine whether a given user is currently over their maximum
 *   device limit.
 *   </dd>
 * <dt>showChoiceScreen</dt>
 *   <dd>
 *   Whether the client should attempt to render a choice screen to the user.
 *   The server takes care of the logic that determines whether it is
 *   appropriate to show the choice screen.
 *   </dd>
 * <dt>clientSyncRateConfig</dt>
 *   <dd>
 *   If present, then this is a set of values to govern how quickly a client can
 *   up-sync and down-sync changes to/from the service.  This field allows the
 *   service to manage the tradeoff between server load and user experience when
 *   synchronizing state between clients and the service.
 *   </dd>
 * </dl>
 */
@interface EDAMSyncState : FATObject 
@property (nonatomic, strong) NSNumber * currentTime; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * fullSyncBefore; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * updateCount; // int32_t
@property (nonatomic, strong) NSNumber * uploaded; // int64_t
@property (nonatomic, strong) NSNumber * userLastUpdated; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * userMaxMessageEventId; // EDAMMessageEventID
@property (nonatomic, strong) NSNumber * businessSummaryUpdated; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * communicationEngineUpdateId; // int32_t
@property (nonatomic, strong) NSNumber * currentDevicesUsed; // int32_t
@property (nonatomic, strong) NSNumber * showChoiceScreen; // BOOL
@property (nonatomic, strong) EDAMClientSyncRateConfig * clientSyncRateConfig;
@end

/*
 * This structure stores user preferences that need to be synchronized via the Evernote
 * service. These preferences exist outside of the core Evernote data model and are
 * opaque to the Evernote service itself.
 * 
 * <p>Individual preferences stored in this structure represent a user's explicit
 * choices about the desired behavior of a client application, for settings that the user
 * would expect to persist when the software is installed on a new device.</p>
 * 
 * <p>Preferences are expected to be updated infrequently and only when a user makes an
 * explicit choice, such as adding a notebook to their list of shortcuts. Preferences may
 * not be updated automatically by a client for purposes such as storing an application's
 * last launch time, nor may they be updated automatically when a user takes an unrelated
 * action, such as storing the number of times that a user has used a given feature of a
 * client.<p>
 * 
 * <p>Preferences may only be used to store choices that differ from client default
 * behavior. A client may not write its default settings into a user's Preferences.</p>
 * 
 * <p>Examples of appropriate uses of the Preferences structure include synchronization
 * of a user's Moleskine "smart stickers" mappings and synchronization of a user's list
 * of shortcuts.</p>
 * 
 * <p>Examples of inappropriate uses of the Preferences structure include storing an
 * application's window size and position, storing any form of client usage metrics,
 * and storing large blobs of binary data such as images.</p>
 * 
 * <p>Preferences are stored as a mapping from preference name to an ordered list of
 * values corresponding to that name. Standard preference names are defined in
 * Limits.thrift. The maximum length of a preference name is 32 characters
 * (EDAM_PREFERENCE_NAME_LEN_MAX). Preference names may not include control characters,
 * spaces or carriage returns.</p>
 * 
 * <p>Preferences names used by Evernote clients should always be prepended with the
 * string "evernote.". If the preference is specific to a given client, the client's
 * canonical name should then be appended (e.g. "food", "hello" or "skitch"), followed
 * by a descriptive name for the preference, if necessary. Preferences names should always
 * be lower-case. Valid names include "evernote.shortcuts", "evernote.food", and
 * "evernote.skitch.stampsettings". Invalid names include "food.recipeNotebooks" and
 * "evernote.skitchStampSettings". Preferences used by more one Evernote client, such as
 * "evernote.shortcuts", must be registered in Limits.thrift.</p>
 * 
 * <p>In some cases it is appropriate to use a separate Preferences entry to represent the
 * setting that is being stored. For example, a user's shortcuts list is stored in the
 * "evernote.shortcuts" preference. In other cases, it is appropriate for a client to use
 * a single Preferences entry to store all of its settings. A client should use the
 * minimum number of preferences entries required to meet its needs.</p>
 * 
 * <dl>
 * <dt>updateSequenceNum</dt>
 *   <dd>
 *   The update sequence number for the preferences of this account.
 *   Note that the update sequence number scopes the entire collections of preferences
 *   and not a single name/value pair.
 *   </dd>
 * 
 * <dt>preferences</dt>
 *   <dd>
 *   A map from names to values where the values are an ordered list of strings.
 *   </dd>
 * </dl>
 */
@interface EDAMPreferences : FATObject 
@property (nonatomic, strong) NSNumber * updateSequenceNum; // int32_t
@property (nonatomic, strong) NSDictionary<NSString *,NSArray<NSString *> *> * preferences;
@end

/*
 *  This structure is given out by the NoteStore when a client asks to
 *  receive the current state of an account.  The client asks for the server's
 *  state one chunk at a time in order to allow clients to retrieve the state
 *  of a large account without needing to transfer the entire account in
 *  a single message.
 * 
 *  The server always gives SyncChunks using an ascending series of Update
 *  Sequence Numbers (USNs).
 * 
 * <dl>
 *  <dt>currentTime</dt>
 *    <dd>
 *    The server's current date and time.
 *    </dd>
 * 
 *  <dt>chunkHighUSN</dt>
 *    <dd>
 *    The highest USN for any of the data objects represented
 *    in this sync chunk.  If there are no objects in the chunk, this will not be
 *    set.
 *    </dd>
 * 
 *  <dt>updateCount</dt>
 *    <dd>
 *    The total number of updates that have been performed in
 *    the service for this account.  This is equal to the highest USN within the
 *    account at the point that this SyncChunk was generated.  If updateCount
 *    and chunkHighUSN are identical, that means that this is the last chunk
 *    in the account ... there is no more recent information.
 *    </dd>
 * 
 *  <dt>notes</dt>
 *    <dd>
 *    If present, this is a list of non-expunged notes that
 *    have a USN in this chunk.  This will include notes that are "deleted"
 *    but not expunged (i.e. in the trash).  The notes will include their list
 *    of tags and resources, but the note content, resource content, resource
 *    recognition data and resource alternate data will not be supplied.
 *    </dd>
 * 
 *  <dt>notebooks</dt>
 *    <dd>
 *    If present, this is a list of non-expunged notebooks that
 *    have a USN in this chunk.
 *    </dd>
 * 
 *  <dt>tags</dt>
 *    <dd>
 *    If present, this is a list of the non-expunged tags that have a
 *    USN in this chunk.
 *    </dd>
 * 
 *  <dt>searches</dt>
 *    <dd>
 *    If present, this is a list of non-expunged searches that
 *    have a USN in this chunk.
 *    </dd>
 * 
 *  <dt>resources</dt>
 *    <dd>
 *    If present, this is a list of the non-expunged resources
 *    that have a USN in this chunk.  This will include the metadata for each
 *    resource, but not its binary contents or recognition data, which must be
 *    retrieved separately.
 *    </dd>
 * 
 *  <dt>expungedNotes</dt>
 *    <dd>
 *    If present, the GUIDs of all of the notes that were
 *    permanently expunged in this chunk.
 *    </dd>
 * 
 *  <dt>expungedNotebooks</dt>
 *    <dd>
 *    If present, the GUIDs of all of the notebooks that
 *    were permanently expunged in this chunk.  When a notebook is expunged,
 *    this implies that all of its child notes (and their resources) were
 *    also expunged.
 *    </dd>
 * 
 *  <dt>expungedTags</dt>
 *    <dd>
 *    If present, the GUIDs of all of the tags that were
 *    permanently expunged in this chunk.
 *    </dd>
 * 
 *  <dt>expungedSearches</dt>
 *    <dd>
 *    If present, the GUIDs of all of the saved searches
 *    that were permanently expunged in this chunk.
 *    </dd>
 * 
 *  <dt>linkedNotebooks</dt>
 *    <dd>
 *    If present, this is a list of non-expunged LinkedNotebooks that
 *    have a USN in this chunk.
 *    </dd>
 * 
 *  <dt>expungedLinkedNotebooks</dt>
 *    <dd>
 *    If present, the GUIDs of all of the LinkedNotebooks
 *    that were permanently expunged in this chunk.
 *    </dd>
 * 
 *  <dt>preferences</dt>
 *    <dd>
 *    If present, this is a Preferences structure that has
 *    a USN in this chunk. INTERNAL ONLY!
 *    </dd>
 * 
 *  <dt>notesNoLongerSharedWithMe</dt>
 *    <dd>
 *    If you set SyncChunkFilter.includeNotesSharedWithMe and
 *    SyncChunkFilter.includeExpunged, then this field will be populated
 *    with the GUIDs of notes that are no longer shared with the recipient
 *    via an assigned Note.sharedNotes record.  Note that the presence of this
 *    flag will not change anything in the expungedNotes field.  That field
 *    is still populated based on loss of notebook-level permissions and
 *    server-side expunges.
 *    </dd>
 *  </dl>
 * 
 *  <dt>linkedAccounts</dt>
 *    <dd>
 *    If present, this is a list of non-expunged LinkedAccounts that
 *    have a USN in this chunk.
 *    </dd>
 * 
 *  <dt>expungedLinkedAccounts</dt>
 *    <dd>
 *    If present, the GUIDs of all of the LinkedAccounts
 *    that were permanently expunged in this chunk.  INTERNAL ONLY!
 *    </dd>
 * 
 */
@interface EDAMSyncChunk : FATObject 
@property (nonatomic, strong) NSNumber * currentTime; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * chunkHighUSN; // int32_t
@property (nonatomic, strong) NSNumber * updateCount; // int32_t
@property (nonatomic, strong) NSArray<EDAMNote *> * notes;
@property (nonatomic, strong) NSArray<EDAMNotebook *> * notebooks;
@property (nonatomic, strong) NSArray<EDAMTag *> * tags;
@property (nonatomic, strong) NSArray<EDAMSavedSearch *> * searches;
@property (nonatomic, strong) NSArray<EDAMResource *> * resources;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedNotes;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedNotebooks;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedTags;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedSearches;
@property (nonatomic, strong) NSArray<EDAMLinkedNotebook *> * linkedNotebooks;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedLinkedNotebooks;
@property (nonatomic, strong) EDAMPreferences * preferences;
@property (nonatomic, strong) NSArray<EDAMGuid> * notesNoLongerSharedWithMe;
@property (nonatomic, strong) NSArray<EDAMLinkedAccount *> * linkedAccounts;
@property (nonatomic, strong) NSArray<EDAMGuid> * expungedLinkedAccounts;
@end

/*
 *  This structure is used with the 'getFilteredSyncChunk' call to provide
 *  fine-grained control over the data that's returned when a client needs
 *  to synchronize with the service. Each flag in this structure specifies
 *  whether to include one class of data in the results of that call.
 * 
 * <dl>
 *  <dt>includeNotes</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.notes field
 *    </dd>
 * 
 *  <dt>includeNoteResources</dt>
 *    <dd>
 *    If true, then the server will include the 'resources' field on all of
 *    the Notes that are in SyncChunk.notes.
 *    If 'includeNotes' is false, then this will have no effect.
 *    </dd>
 * 
 *  <dt>includeNoteAttributes</dt>
 *    <dd>
 *    If true, then the server will include the 'attributes' field on all of
 *    the Notes that are in SyncChunks.notes.
 *    If 'includeNotes' is false, then this will have no effect.
 *    </dd>
 * 
 *  <dt>includeNotebooks</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.notebooks field
 *    </dd>
 * 
 *  <dt>includeTags</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.tags field
 *    </dd>
 * 
 *  <dt>includeSearches</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.searches field
 *    </dd>
 * 
 *  <dt>includeResources</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.resources field.
 *    Since the Resources are also provided with their Note
 *    (in the Notes.resources list), this is primarily useful for clients that
 *    want to watch for changes to individual Resources due to recognition data
 *    being added.
 *    </dd>
 * 
 *  <dt>includeLinkedNotebooks</dt>
 *    <dd>
 *    If true, then the server will include the SyncChunks.linkedNotebooks field.
 *    </dd>
 * 
 *  <dt>includeExpunged</dt>
 *    <dd>
 *    If true, then the server will include the 'expunged' data for any type
 *    of included data.  For example, if 'includeTags' and 'includeExpunged'
 *    are both true, then the SyncChunks.expungedTags field will be set with
 *    the GUIDs of tags that have been expunged from the server.
 *    </dd>
 * 
 *  <dt>includeNoteApplicationDataFullMap</dt>
 *    <dd>
 *    If true, then the values for the applicationData map will be filled
 *    in, assuming notes and note attributes are being returned.  Otherwise,
 *    only the keysOnly field will be filled in.
 *    </dd>
 * 
 *  <dt>includeResourceApplicationDataFullMap</dt>
 *    <dd>
 *    If true, then the fullMap values for the applicationData map will be
 *    filled in, assuming resources and resource attributes are being returned
 *    (includeResources is true).  Otherwise, only the keysOnly field will be
 *    filled in.
 *    </dd>
 * 
 *  <dt>includeNoteResourceApplicationDataFullMap</dt>
 *    <dd>
 *    If true, then the fullMap values for the applicationData map will be
 *    filled in for resources found inside of notes, assuming resources are
 *    being returned in notes (includeNoteResources is true).  Otherwise,
 *    only the keysOnly field will be filled in.
 *    </dd>
 * 
 *  <dt>includePreferences</dt>
 *    <dd>
 *    If true, then the server will include the "preferences" field.
 *    INTERNAL ONLY!
 *    </dd>
 * 
 *  <dt>omitSharedNotebooks<dt>
 *    <dd>
 *    Normally, if 'includeNotebooks' is true, then the SyncChunks will
 *    include Notebooks that may include a set of SharedNotebook
 *    invitations via Notebook.sharedNotebookIds and Notebook.sharedNotebooks.
 *    However, if omitSharedNotebooks is set to true, then the Notebooks
 *    will omit those two fields and leave them unset. This should be used
 *    by clients who want to know their own set of Notebooks (and the
 *    associated permissions via Notebook.recipientSettings), and who
 *    do not need to know the full set of other people who can also see
 *    that same notebook.
 *    </dd>
 * 
 *  <dt>requireNoteContentClass</dt>
 *    <dd>
 *    If set, then only send notes whose content class matches this value.
 *    The value can be a literal match or, if the last character is an
 *    asterisk, a prefix match.
 *    </dd>
 * 
 *  <dt>notebookGuids</dt>
 *    <dd>
 *    If set, then restrict the returned notebooks, notes, and
 *    resources to those associated with one of the notebooks whose
 *    GUID is provided in this list.  If not set, then no filtering on
 *    notebook GUID will be performed.  If you set this field, you may
 *    not also set includeExpunged else an EDAMUserException with an
 *    error code of DATA_CONFLICT will be thrown.  You only need to set
 *    this field if you want to restrict the returned entities more
 *    than what your authentication token allows you to access.  For
 *    example, there is no need to set this field for single notebook
 *    tokens such as for shared notebooks.  You can use this field to
 *    synchronize a newly discovered business notebook while
 *    incrementally synchronizing a business account, in which case you
 *    will only need to consider setting includeNotes,
 *    includeNotebooks, includeNoteAttributes, includeNoteResources,
 *    and maybe some of the "FullMap" fields.
 *    </dd>
 * 
 *  <dt>includeSharedNotes</dt>
 *    <dd>
 *    If true, then the service will include the sharedNotes field on all
 *    notes that are in SyncChunk.notes. If 'includeNotes' is false, then
 *    this will have no effect.
 *    </dd>
 * 
 *  <dt>includeNotesSharedWithMe</dt>
 *    <dd>
 *    If true, then the service will include information about the
 *    assigned notes that are shared with the recipient, individually,
 *    via an assigned Note.sharedNote record.  The notes will be
 *    included in SyncChunk.notes.  Note that by setting
 *    SyncChunkFilter.includeExpunged, you will NOT receive anything
 *    different in the SyncChunk.expungedNotes field!  The field will
 *    continue to be populated based on Notebook permissions and
 *    explicit expunges on the Service.  This is a short-term
 *    implementation limitation, and Evernote is working on larger
 *    changes to its architecture to fundamentally improve the sync
 *    experience.  What this means is that you will need to avoid
 *    expunging your local copy of a note if the note is still shared
 *    individually with you when receiving an expungedNotes event.
 *    Also, for business sync, when clearing notes at the end of sync
 *    for an expunged notebook, you should leave notes that are shared
 *    individually with the recipient.  To implement this, when you
 *    receive the note, you should check the Note.restrictions field.
 *    If it exists, the note is shared with the recipient and you
 *    should persist this fact.  When the note is no longer shared with
 *    the recipient via an assigned Note.sharedNote record, the service
 *    will include the GUID in SyncChunk.notesNoLongerSharedWithMe and
 *    you should persist that.  If, at the end of sync, you have notes
 *    that are not shared individually with the recipient and which are
 *    not in a notebook that the recipient has in-my-list, the local
 *    copy can be cleaned up.
 *    </dd>
 * 
 *  <dt>inAccountUserId</dt>
 *    <dd>
 *    A special-case field used only in conjunction with includeNotesSharedWithMe
 *    when synchronizing from an account that is not "your" account or your
 *    business account.  This field is the user ID of the account from which to
 *    synchronize "your" shared notes.
 *    </dd>
 *  </dl>
 */
@interface EDAMSyncChunkFilter : FATObject 
@property (nonatomic, strong) NSNumber * includeNotes; // BOOL
@property (nonatomic, strong) NSNumber * includeNoteResources; // BOOL
@property (nonatomic, strong) NSNumber * includeNoteAttributes; // BOOL
@property (nonatomic, strong) NSNumber * includeNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * includeTags; // BOOL
@property (nonatomic, strong) NSNumber * includeSearches; // BOOL
@property (nonatomic, strong) NSNumber * includeResources; // BOOL
@property (nonatomic, strong) NSNumber * includeLinkedNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * includeExpunged; // BOOL
@property (nonatomic, strong) NSNumber * includeNoteApplicationDataFullMap; // BOOL
@property (nonatomic, strong) NSNumber * includeResourceApplicationDataFullMap; // BOOL
@property (nonatomic, strong) NSNumber * includeNoteResourceApplicationDataFullMap; // BOOL
@property (nonatomic, strong) NSNumber * includePreferences; // BOOL
@property (nonatomic, strong) NSNumber * includeSharedNotes; // BOOL
@property (nonatomic, strong) NSNumber * includeNotesSharedWithMe; // BOOL
@property (nonatomic, strong) NSNumber * includeLinkedAccounts; // BOOL
@property (nonatomic, strong) NSNumber * omitSharedNotebooks; // BOOL
@property (nonatomic, strong) NSString * requireNoteContentClass;
@property (nonatomic, strong) NSSet<NSString *> * notebookGuids;
@property (nonatomic, strong) NSNumber * inAccountUserId; // EDAMUserID
@end

/*
 *  A list of criteria that are used to indicate which notes are desired from
 *  the account.  This is used in queries to the NoteStore to determine
 *  which notes should be retrieved.
 * 
 * <dl>
 *  <dt>order</dt>
 *    <dd>
 *    The NoteSortOrder value indicating what criterion should be
 *    used to sort the results of the filter.
 *    </dd>
 * 
 *  <dt>ascending</dt>
 *    <dd>
 *    If true, the results will be ascending in the requested
 *    sort order.  If false, the results will be descending.
 *    </dd>
 * 
 *  <dt>words</dt>
 *    <dd>
 *    If present, a search query string that will filter the set of notes to be returned.
 *    Accepts the full search grammar documented in the Evernote API Overview.
 *    </dd>
 * 
 *  <dt>notebookGuid</dt>
 *    <dd>
 *    If present, the Guid of the notebook that must contain
 *    the notes.
 *    </dd>
 * 
 *  <dt>tagGuids</dt>
 *    <dd>
 *    If present, the list of tags (by GUID) that must be present
 *    on the notes.
 *    </dd>
 * 
 *  <dt>timeZone</dt>
 *    <dd>
 *    The zone ID for the user, which will be used to interpret
 *    any dates or times in the queries that do not include their desired zone
 *    information.
 *    For example, if a query requests notes created "yesterday", this
 *    will be evaluated from the provided time zone, if provided.
 *    The format must be encoded as a standard zone ID such as
 *    "America/Los_Angeles".
 *    </dd>
 * 
 *  <dt>inactive</dt>
 *    <dd>
 *    If true, then only notes that are not active (i.e. notes in
 *    the Trash) will be returned. Otherwise, only active notes will be returned.
 *    There is no way to find both active and inactive notes in a single query.
 *    </dd>
 * 
 *  <dt>emphasized</dt>
 *    <dd>
 *    If present, a search query string that may or may not influence the notes
 *    to be returned, both in terms of coverage as well as of order. Think of it
 *    as a wish list, not a requirement.
 *    Accepts the full search grammar documented in the Evernote API Overview.
 *    </dd>
 * 
 *  <dt>includeAllReadableNotebooks</dt>
 *    <dd>
 *    If true, then the search will include all business notebooks that are readable
 *    by the user. A business authentication token must be supplied for
 *    this option to take effect when calling search APIs.
 *    </dd>
 * 
 *  <dt>context</dt>
 *  <dd>Specifies the context to consider when determining result ranking.
 *      Clients must leave this value unset unless they wish to explicitly specify a known
 *      non-default context.
 *  </dd>
 * 
 *  </dl>
 */
@interface EDAMNoteFilter : FATObject 
@property (nonatomic, strong) NSNumber * order; // int32_t
@property (nonatomic, strong) NSNumber * ascending; // BOOL
@property (nonatomic, strong) NSString * words;
@property (nonatomic, strong) EDAMGuid notebookGuid;
@property (nonatomic, strong) NSArray<EDAMGuid> * tagGuids;
@property (nonatomic, strong) NSString * timeZone;
@property (nonatomic, strong) NSNumber * inactive; // BOOL
@property (nonatomic, strong) NSString * emphasized;
@property (nonatomic, strong) NSNumber * includeAllReadableNotebooks; // BOOL
@property (nonatomic, strong) NSString * context;
@end

/*
 *  A small structure for returning a list of notes out of a larger set.
 * 
 * <dl>
 *  <dt>startIndex</dt>
 *    <dd>
 *    The starting index within the overall set of notes.  This
 *    is also the number of notes that are "before" this list in the set.
 *    </dd>
 * 
 *  <dt>totalNotes</dt>
 *    <dd>
 *    The number of notes in the larger set.  This can be used
 *    to calculate how many notes are "after" this note in the set.
 *    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
 *    </dd>
 * 
 *  <dt>notes</dt>
 *    <dd>
 *    The list of notes from this range.  The Notes will include all
 *    metadata (attributes, resources, etc.), but will not include the ENML
 *    content of the note or the binary contents of any resources.
 *    </dd>
 * 
 *  <dt>stoppedWords</dt>
 *    <dd>
 *    If the NoteList was produced using a text based search
 *    query that included words that are not indexed or searched by the service,
 *    this will include a list of those ignored words.
 *    </dd>
 * 
 *  <dt>searchedWords</dt>
 *    <dd>
 *    If the NoteList was produced using a text based search
 *    query that included viable search words or quoted expressions, this will
 *    include a list of those words.  Any stopped words will not be included
 *    in this list.
 *    </dd>
 * 
 *  <dt>updateCount</dt>
 *    <dd>
 *    Indicates the total number of transactions that have
 *    been committed within the account.  This reflects (for example) the
 *    number of discrete additions or modifications that have been made to
 *    the data in this account (tags, notes, resources, etc.).
 *    This number is the "high water mark" for Update Sequence Numbers (USN)
 *    within the account.
 *    </dd>
 *  </dl>
 */
@interface EDAMNoteList : FATObject 
@property (nonatomic, strong) NSNumber * startIndex; // int32_t
@property (nonatomic, strong) NSNumber * totalNotes; // int32_t
@property (nonatomic, strong) NSArray<EDAMNote *> * notes;
@property (nonatomic, strong) NSArray<NSString *> * stoppedWords;
@property (nonatomic, strong) NSArray<NSString *> * searchedWords;
@property (nonatomic, strong) NSNumber * updateCount; // int32_t
@end

/*
 * This structure is used in the set of results returned by the
 * findNotesMetadata function.  It represents the high-level information about
 * a single Note, without some of the larger deep structure.  This allows
 * for the information about a list of Notes to be returned relatively quickly
 * with less marshalling and data transfer to remote clients.
 * Most fields in this structure are identical to the corresponding field in
 * the Note structure, with the exception of:
 * 
 * <dl>
 * <dt>largestResourceMime</dt>
 *   <dd>If set, then this will contain the MIME type of the largest Resource
 *   (in bytes) within the Note.  This may be useful, for example, to choose
 *   an appropriate icon or thumbnail to represent the Note.
 *   </dd>
 * 
 * <dt>largestResourceSize</dt>
 *  <dd>If set, this will contain the size of the largest Resource file, in
 *  bytes, within the Note.  This may be useful, for example, to decide whether
 *  to ask the server for a thumbnail to represent the Note.
 *  </dd>
 * </dl>
 */
@interface EDAMNoteMetadata : FATObject 
@property (nonatomic, strong) EDAMGuid guid;
@property (nonatomic, strong) NSString * title;
@property (nonatomic, strong) NSNumber * contentLength; // int32_t
@property (nonatomic, strong) NSNumber * created; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * updated; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * deleted; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * updateSequenceNum; // int32_t
@property (nonatomic, strong) NSString * notebookGuid;
@property (nonatomic, strong) NSArray<EDAMGuid> * tagGuids;
@property (nonatomic, strong) EDAMNoteAttributes * attributes;
@property (nonatomic, strong) NSString * largestResourceMime;
@property (nonatomic, strong) NSNumber * largestResourceSize; // int32_t
@end

/*
 *  This structure is returned from calls to the findNotesMetadata function to
 *  give the high-level metadata about a subset of Notes that are found to
 *  match a specified NoteFilter in a search.
 * 
 * <dl>
 *  <dt>startIndex</dt>
 *    <dd>
 *    The starting index within the overall set of notes.  This
 *    is also the number of notes that are "before" this list in the set.
 *    </dd>
 * 
 *  <dt>totalNotes</dt>
 *    <dd>
 *    The number of notes in the larger set.  This can be used
 *    to calculate how many notes are "after" this note in the set.
 *    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
 *    </dd>
 * 
 *  <dt>notes</dt>
 *    <dd>
 *    The list of metadata for Notes in this range.  The set of optional fields
 *    that are set in each metadata structure will depend on the
 *    NotesMetadataResultSpec provided by the caller when the search was
 *    performed.  Only the 'guid' field will be guaranteed to be set in each
 *    Note.
 *    </dd>
 * 
 *  <dt>stoppedWords</dt>
 *    <dd>
 *    If the NoteList was produced using a text based search
 *    query that included words that are not indexed or searched by the service,
 *    this will include a list of those ignored words.
 *    </dd>
 * 
 *  <dt>searchedWords</dt>
 *    <dd>
 *    If the NoteList was produced using a text based search
 *    query that included viable search words or quoted expressions, this will
 *    include a list of those words.  Any stopped words will not be included
 *    in this list.
 *    </dd>
 * 
 *  <dt>updateCount</dt>
 *    <dd>
 *    Indicates the total number of transactions that have
 *    been committed within the account.  This reflects (for example) the
 *    number of discrete additions or modifications that have been made to
 *    the data in this account (tags, notes, resources, etc.).
 *    This number is the "high water mark" for Update Sequence Numbers (USN)
 *    within the account.
 *    </dd>
 *  </dl>
 */
@interface EDAMNotesMetadataList : FATObject 
@property (nonatomic, strong) NSNumber * startIndex; // int32_t
@property (nonatomic, strong) NSNumber * totalNotes; // int32_t
@property (nonatomic, strong) NSArray<EDAMNoteMetadata *> * notes;
@property (nonatomic, strong) NSArray<NSString *> * stoppedWords;
@property (nonatomic, strong) NSArray<NSString *> * searchedWords;
@property (nonatomic, strong) NSNumber * updateCount; // int32_t
@end

/*
 * This structure is provided to the findNotesMetadata function to specify
 * the subset of fields that should be included in each NoteMetadata element
 * that is returned in the NotesMetadataList.
 * Each field on this structure is a boolean flag that indicates whether the
 * corresponding field should be included in the NoteMetadata structure when
 * it is returned.  For example, if the 'includeTitle' field is set on this
 * structure when calling findNotesMetadata, then each NoteMetadata in the
 * list should have its 'title' field set.
 * If one of the fields in this spec is not set, then it will be treated as
 * 'false' by the server, so the default behavior is to include nothing in
 * replies (but the mandatory GUID)
 */
@interface EDAMNotesMetadataResultSpec : FATObject 
@property (nonatomic, strong) NSNumber * includeTitle; // BOOL
@property (nonatomic, strong) NSNumber * includeContentLength; // BOOL
@property (nonatomic, strong) NSNumber * includeCreated; // BOOL
@property (nonatomic, strong) NSNumber * includeUpdated; // BOOL
@property (nonatomic, strong) NSNumber * includeDeleted; // BOOL
@property (nonatomic, strong) NSNumber * includeUpdateSequenceNum; // BOOL
@property (nonatomic, strong) NSNumber * includeNotebookGuid; // BOOL
@property (nonatomic, strong) NSNumber * includeTagGuids; // BOOL
@property (nonatomic, strong) NSNumber * includeAttributes; // BOOL
@property (nonatomic, strong) NSNumber * includeLargestResourceMime; // BOOL
@property (nonatomic, strong) NSNumber * includeLargestResourceSize; // BOOL
@end

/*
 *  A data structure representing the number of notes for each notebook
 *  and tag with a non-zero set of applicable notes.
 * 
 * <dl>
 *  <dt>notebookCounts</dt>
 *    <dd>
 *    A mapping from the Notebook GUID to the number of
 *    notes (from some selection) that are in the corresponding notebook.
 *    </dd>
 * 
 *  <dt>tagCounts</dt>
 *    <dd>
 *    A mapping from the Tag GUID to the number of notes (from some
 *    selection) that have the corresponding tag.
 *    </dd>
 * 
 *  <dt>trashCount</dt>
 *    <dd>
 *    If this is set, then this is the number of notes that are in the trash.
 *    If this is not set, then the number of notes in the trash hasn't been
 *    reported.  (I.e. if there are no notes in the trash, this will be set
 *    to 0.)
 *    </dd>
 *  </dl>
 */
@interface EDAMNoteCollectionCounts : FATObject 
@property (nonatomic, strong) NSDictionary<EDAMGuid,NSNumber *> * notebookCounts;
@property (nonatomic, strong) NSDictionary<EDAMGuid,NSNumber *> * tagCounts;
@property (nonatomic, strong) NSNumber * trashCount; // int32_t
@end

/*
 * This structure is provided to the getNoteWithResultSpec function to specify the subset of
 * fields that should be included in the Note that is returned. This allows clients to request
 * the minimum set of information that they require when retrieving a note, reducing the size
 * of the response and improving the response time.
 * 
 * If one of the fields in this spec is not set, then it will be treated as 'false' by the service,
 * so that the default behavior is to include none of the fields below in the Note.
 * 
 * <dl>
 *   <dt>includeContent</dt>
 *   <dd>If true, the Note.content field will be populated with the note's ENML contents.</dd>
 * 
 *   <dt>includeResourcesData</dt>
 *   <dd>If true, any Resource elements will include the binary contents of their 'data' field's
 *     body.</dd>
 * 
 *   <dt>includeResourcesRecognition</dt>
 *   <dd>If true, any Resource elements will include the binary contents of their 'recognition'
 *     field's body if recognition data is available.</dd>
 * 
 *   <dt>includeResourcesAlternateData</dt>
 *   <dd>If true, any Resource elements will include the binary contents of their 'alternateData'
 *     field's body, if an alternate form is available.</dd>
 * 
 *   <dt>includeSharedNotes</dt>
 *   <dd>If true, the Note.sharedNotes field will be populated with the note's shares.</dd>
 * 
 *   <dt>includeNoteAppDataValues</dt>
 *   <dd>If true, the Note.attributes.applicationData.fullMap field will be populated.</dd>
 * 
 *   <dt>includeResourceAppDataValues</dt>
 *   <dd>If true, the Note.resource.attributes.applicationData.fullMap field will be populated.</dd>
 * 
 *   <dt>includeAccountLimits</dt>
 *   <dd>If true, the Note.limits field will be populated with the note owner's account limits.</dd>
 * </dl>
 */
@interface EDAMNoteResultSpec : FATObject 
@property (nonatomic, strong) NSNumber * includeContent; // BOOL
@property (nonatomic, strong) NSNumber * includeResourcesData; // BOOL
@property (nonatomic, strong) NSNumber * includeResourcesRecognition; // BOOL
@property (nonatomic, strong) NSNumber * includeResourcesAlternateData; // BOOL
@property (nonatomic, strong) NSNumber * includeSharedNotes; // BOOL
@property (nonatomic, strong) NSNumber * includeNoteAppDataValues; // BOOL
@property (nonatomic, strong) NSNumber * includeResourceAppDataValues; // BOOL
@property (nonatomic, strong) NSNumber * includeAccountLimits; // BOOL
@end

/*
 * Information for tracking the display of a particular ad by a client.
 * 
 * <dl>
 *  <dt>adId</dt>
 *    <dd>
 *      The identifier for this ad, from a previous Ad.id given to the client
 *    </dd>
 * 
 *  <dt>impressionCount</dt>
 *    <dd>
 *      The number of times this ad was displayed since the last successful
 *      ad retrieval.  The client should only report times the ad was selected
 *      when the client was visible.
 *    </dd>
 * 
 *  <dt>impressionTime</dt>
 *    <dd>
 *      The number of seconds that the client displayed the advertisement since
 *      the last successful ad retrieval.  This corresponds to the seconds that
 *      the client application was visible.
 *    </dd>
 * </dl>
 */
@interface EDAMAdImpressions : FATObject 
@property (nonatomic, strong) NSNumber * adId; // int32_t
@property (nonatomic, strong) NSNumber * impressionCount; // int32_t
@property (nonatomic, strong) NSNumber * impressionTime; // int32_t
@end

/*
 * Parameters that will be given by a client to the service when it requests
 * a set of advertisements to display.  If any of these values are omitted,
 * the service will use default values.
 * 
 * <dl>
 *  <dt>clientLanguage</dt>
 *    <dd>
 *      The ISO 639-1 language code for the primary language for the client.
 *      If omitted, English will be assumed ('en').
 *    </dd>
 * 
 *  <dt>impressions</dt>
 *    <dd>
 *      A list of the impression counts and total display time for the ads
 *      that were displayed in the last day.
 *    </dd>
 * 
 *  <dt>supportHtml</dt>
 *    <dd>
 *      If true, the client requesting the ads supports ads specified via
 *      general HTML (with rich media, Javascript, etc.).
 *    </dd>
 * 
 *  <dt>clientProperties</dt>
 *    <dd>
 *      If provided, this may contain a set of key/value pairs that identify
 *      the characteristics of a particular client that may be used to help
 *      determine appropriate ads for that client.  These tuples may be used
 *      either to reduce or increase the likelihood that each ad will be
 *      returned.
 *    </dd>
 * </dl>
 */
@interface EDAMAdParameters : FATObject 
@property (nonatomic, strong) NSString * clientLanguage;
@property (nonatomic, strong) NSArray<EDAMAdImpressions *> * impressions;
@property (nonatomic, strong) NSNumber * supportHtml; // BOOL
@property (nonatomic, strong) NSDictionary<NSString *,NSString *> * clientProperties;
@end

/*
 * Parameters that must be given to the NoteStore emailNote call. These allow
 * the caller to specify the note to send, the recipient addresses, etc.
 * 
 * <dl>
 *  <dt>guid</dt>
 *    <dd>
 *      If set, this must be the GUID of a note within the user's account that
 *      should be retrieved from the service and sent as email.  If not set,
 *      the 'note' field must be provided instead.
 *    </dd>
 * 
 *  <dt>note</dt>
 *    <dd>
 *      If the 'guid' field is not set, this field must be provided, including
 *      the full contents of the note note (and all of its Resources) to send.
 *      This can be used for a Note that as not been created in the service,
 *      for example by a local client with local notes.
 *    </dd>
 * 
 *  <dt>toAddresses</dt>
 *    <dd>
 *      If provided, this should contain a list of the SMTP email addresses
 *      that should be included in the "To:" line of the email.
 *      Callers must specify at least one "to" or "cc" email address.
 *    </dd>
 * 
 *  <dt>ccAddresses</dt>
 *    <dd>
 *      If provided, this should contain a list of the SMTP email addresses
 *      that should be included in the "Cc:" line of the email.
 *      Callers must specify at least one "to" or "cc" email address.
 *    </dd>
 * 
 *  <dt>subject</dt>
 *    <dd>
 *      If provided, this should contain the subject line of the email that
 *      will be sent.  If not provided, the title of the note will be used
 *      as the subject of the email.
 *    </dd>
 * 
 *  <dt>message</dt>
 *    <dd>
 *      If provided, this is additional personal text that should be included
 *      into the email as a message from the owner to the recipient(s).
 *    </dd>
 * </dl>
 */
@interface EDAMNoteEmailParameters : FATObject 
@property (nonatomic, strong) NSString * guid;
@property (nonatomic, strong) EDAMNote * note;
@property (nonatomic, strong) NSArray<NSString *> * toAddresses;
@property (nonatomic, strong) NSArray<NSString *> * ccAddresses;
@property (nonatomic, strong) NSString * subject;
@property (nonatomic, strong) NSString * message;
@end

/*
 * Identifying information about previous versions of a note that are backed up
 * within Evernote's servers.  Used in the return value of the listNoteVersions
 * call.
 * 
 * <dl>
 *  <dt>updateSequenceNum</dt>
 *  <dd>
 *    The update sequence number for the Note when it last had this content.
 *    This serves to uniquely identify each version of the note, since USN
 *    values are unique within an account for each update.
 *  </dd>
 *  <dt>updated</dt>
 *  <dd>
 *    The 'updated' time that was set on the Note when it had this version
 *    of the content.  This is the user-modifiable modification time on the
 *    note, so it's not reliable for guaranteeing the order of various
 *    versions.  (E.g. if someone modifies the note, then changes this time
 *    manually into the past and then updates the note again.)
 *  </dd>
 *  <dt>saved</dt>
 *  <dd>
 *    A timestamp that holds the date and time when this version of the note
 *    was backed up by Evernote's servers.
 *  </dd>
 *  <dt>title</dt>
 *  <dd>
 *    The title of the note when this particular version was saved.  (The
 *    current title of the note may differ from this value.)
 *  </dd>
 *  <dt>lastEditorId</dt>
 *  <dd>
 *    The ID of the user who made the change to this version of the note. This will be
 *    unset if the note version was edited by the owner of the account.
 *  </dd>
 * </dl>
 */
@interface EDAMNoteVersionId : FATObject 
@property (nonatomic, strong) NSNumber * updateSequenceNum; // int32_t
@property (nonatomic, strong) NSNumber * updated; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * saved; // EDAMTimestamp
@property (nonatomic, strong) NSString * title;
@property (nonatomic, strong) NSNumber * lastEditorId; // EDAMUserID
@end

/*
 * This structure is passed from clients to the Evernote service when they wish
 * to relay coarse-grained usage metrics to the service to help improve
 * products.
 * 
 * <dl>
 *  <dt>sessions</dt>
 *  <dd>
 *    This field contains a count of the number of usage "sessions" that have
 *    occurred with this client which have not previously been reported to
 *    the service.
 *    A "session" is defined as one of the 96 fifteen-minute intervals of the
 *    day when someone used Evernote's interface at least once.
 *    So if a user interacts with an Evernote client at 12:18, 12:24, and 12:36,
 *    and then the client synchronizes at 12:39, it would report that there were
 *    two previously-unreported sessions (one session for the 12:15-12:30 time
 *    period, and one for the 12:30-12:45 period).
 *    If the user used Evernote again at 12:41 and synchronized at 12:43, it
 *    would not report any new sessions, because the 12:30-12:45 session had
 *    already been reported.
 *  </dd>
 *  <dt>subjectConsumerKey</dt>
 *  <dd>
 *    For internal use only. See Seth Hitchings if you think you might want to
 *    use this field.
 *    <p>If the client application making the API call is reporting usage metrics
 *    on behalf of another application, this optional field specifies the
 *    consumer key of the application to which the metrics apply.</p>
 *  </dd>
 *  <dt>subjectConsumerSecret</dt>
 *  <dd>
 *    For internal use only. See Seth Hitchings if you think you might want to
 *    use this field.
 *    <p>If the client application making the API call is reporting usage metrics
 *    on behalf of another application, this optional field specifies the
 *    consumer secret of the application to which the metrics apply.</p>
 *  </dd>
 * </dl>
 */
@interface EDAMClientUsageMetrics : FATObject 
@property (nonatomic, strong) NSNumber * sessions; // int32_t
@property (nonatomic, strong) NSString * subjectConsumerKey;
@property (nonatomic, strong) NSString * subjectConsumerSecret;
@end

/*
 * A description of the thing for which we are searching for related
 * entities.
 * 
 * You must specify either <em>noteGuid</em> or <em>plainText</em>, but
 * not both. <em>filter</em> and <em>referenceUri</em> are optional.
 * 
 * <dl>
 * <dt>noteGuid</dt>
 * <dd>The GUID of an existing note in your account for which related
 *     entities will be found.</dd>
 * 
 * <dt>plainText</dt>
 * <dd>A string of plain text for which to find related entities.
 *     You should provide a text block with a number of characters between
 *     EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
 *     </dd>
 * 
 * <dt>filter</dt>
 * <dd>The list of criteria that will constrain the notes being considered
 *     related.
 *     Please note that some of the parameters may be ignored, such as
 *     <em>order</em> and <em>ascending</em>.
 * </dd>
 * 
 * <dt>referenceUri</dt>
 * <dd>A URI string specifying a reference entity, around which "relatedness"
 *     should be based. This can be an URL pointing to a web page, for example.
 * </dd>
 * 
 * <dt>context</dt>
 * <dd>Specifies the context to consider when determining related results.
 *     Clients must leave this value unset unless they wish to explicitly specify a known
 *     non-default context.
 * </dd>
 * 
 * <dt>cacheKey</dt>
 * <dd>If set and non-empty, this is an indicator for the server whether it is actually
 *     necessary to perform a new findRelated call at all. Cache Keys are opaque strings
 *     which are returned by the server as part of "RelatedResult" in response
 *     to a "NoteStore.findRelated" query. Cache Keys are inherently query specific.
 * 
 *     If set to an empty string, this indicates that the server should generate a cache
 *     key in the response as part of "RelatedResult".
 * 
 *     If not set, the server will not attempt to generate a cache key at all.
 * </dd>
 * </dl>
 */
@interface EDAMRelatedQuery : FATObject 
@property (nonatomic, strong) NSString * noteGuid;
@property (nonatomic, strong) NSString * plainText;
@property (nonatomic, strong) EDAMNoteFilter * filter;
@property (nonatomic, strong) NSString * referenceUri;
@property (nonatomic, strong) NSString * context;
@property (nonatomic, strong) NSString * cacheKey;
@end

/*
 * The result of calling findRelated().  The contents of the notes,
 * notebooks, and tags fields will be in decreasing order of expected
 * relevance.  It is possible that fewer results than requested will be
 * returned even if there are enough distinct entities in the account
 * in cases where the relevance is estimated to be low.
 * 
 * <dl>
 * <dt>notes</dt>
 * <dd>If notes have been requested to be included, this will be the
 *     list of notes.</dd>
 * 
 * <dt>notebooks</dt>
 * <dd>If notebooks have been requested to be included, this will be the
 *     list of notebooks.</dd>
 * 
 * <dt>tags</dt>
 * <dd>If tags have been requested to be included, this will be the list
 *     of tags.</dd>
 * 
 * <dt>containingNotebooks</dt>
 * <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
 *     in the RelatedResultSpec, return the list of notebooks to
 *     to which the returned related notes belong. The notebooks in this
 *     list will occur once per notebook GUID and are represented as
 *     NotebookDescriptor objects.</dd>
 * 
 * <dt>debugInfo</dt>
 * <dd>If <code>includeDebugInfo</code> in RelatedResultSpec is set to
 *     <code>true</code>, this field may contain debug information
 *     if the service decides to do so.</dd>
 * 
 * <dt>experts</dt>
 * <dd>If experts have been requested to be included, this will return
 *  a list of users within your business who have knowledge about the specified query.
 * </dd>
 * 
 * <dt>relatedContent</dt>
 * <dd>If related content has been requested to be included, this will be the list of
 *  related content snippets.
 * </dd>
 * 
 * <dt>cacheKey</dt>
 * <dd>If set and non-empty, this cache key may be used in subsequent
 *     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
 *     responses that were cached on the client-side, instead of actually performing
 *     another search.
 * 
 *     If set to an empty string, this indicates that the server could not determine
 *     a specific key for this response, but the client should nevertheless remove
 *     any previously cached result for this request.
 * 
 *     If unset/null, it is up to the client whether to re-use cached results or to
 *     use the server's response.
 * 
 *     If set to the exact non-empty cache key that was specified in
 *     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
 *     could be reused.
 * 
 *     Depending on the cache key specified in the query, the "RelatedResult" may only be
 *     partially filled. For each set field, the client should replace the corresponding
 *     part in the previously cached result with the new partial result.
 * 
 *     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
 *     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
 *     that the previously requested and cached <em>Related Content</em> are unchanged,
 *     but new results for <em>Related Notes</em> are available. The
 *     response will have a new cache key and have "RelatedResult.notes" set, but have
 *     "RelatedResult.relatedContent" unset (not just empty, but really unset).
 * 
 *     In this situation, the client should replace any cached notes with the newly
 *     returned "RelatedResult.notes", but it can re-use the previously cached entries for
 *     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
 *     no results could be found; the cache should be updated correspondingly.
 * </dd>
 * 
 * <dt>cacheExpires</dt>
 * <dd> If set, clients should reuse this response for any situations where the same input
 *      parameters are applicable for up to this many seconds after receiving this result.
 * 
 *      After this time has passed, the client may request a new result from the service,
 *      but it should supply the stored cacheKey to the service when checking for an
 *      update.
 * </dd>
 * 
 * </dl>
 */
@interface EDAMRelatedResult : FATObject 
@property (nonatomic, strong) NSArray<EDAMNote *> * notes;
@property (nonatomic, strong) NSArray<EDAMNotebook *> * notebooks;
@property (nonatomic, strong) NSArray<EDAMTag *> * tags;
@property (nonatomic, strong) NSArray<EDAMNotebookDescriptor *> * containingNotebooks;
@property (nonatomic, strong) NSString * debugInfo;
@property (nonatomic, strong) NSArray<EDAMUserProfile *> * experts;
@property (nonatomic, strong) NSArray<EDAMRelatedContent *> * relatedContent;
@property (nonatomic, strong) NSString * cacheKey;
@property (nonatomic, strong) NSNumber * cacheExpires; // int32_t
@end

/*
 * A description of the thing for which the service will find related
 * entities, via findRelated(), together with a description of what
 * type of entities and how many you are seeking in the
 * RelatedResult.
 * 
 * <dl>
 * <dt>maxNotes</dt>
 * <dd>Return notes that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_NOTES
 *     will be silently capped.  If you do not set this field, then
 *     no notes will be returned.</dd>
 * 
 * <dt>maxNotebooks</dt>
 * <dd>Return notebooks that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
 *     will be silently capped.  If you do not set this field, then
 *     no notebooks will be returned.</dd>
 * 
 * <dt>maxTags</dt>
 * <dd>Return tags that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_TAGS
 *     will be silently capped.  If you do not set this field, then
 *     no tags will be returned.</dd>
 * </dl>
 * 
 * <dt>writableNotebooksOnly</dt>
 * <dd>Require that all returned related notebooks are writable.
 *     The user will be able to create notes in all returned notebooks.
 *     However, individual notes returned may still belong to notebooks
 *     in which the user lacks the ability to create notes.</dd>
 * </dl>
 * 
 * <dt>includeContainingNotebooks</dt>
 * <dd>If set to <code>true</code>, return the containingNotebooks field
 *     in the RelatedResult, which will contain the list of notebooks to
 *     to which the returned related notes belong.</dd>
 * </dl>
 * 
 * <dt>includeDebugInfo</dt>
 * <dd>If set to <code>true</code>, indicate that debug information should
 *     be returned in the 'debugInfo' field of RelatedResult. Note that the call may
 *     be slower if this flag is set.</dd>
 * 
 * <dt>maxExperts</dt>
 * <dd>This can only be used when making a findRelated call against a business.
 *  Find users within your business who have knowledge about the specified query.
 *  No more than this many users will be returned. Any value greater than
 *  EDAM_RELATED_MAX_EXPERTS will be silently capped.
 * </dd>
 * 
 * <dt>maxRelatedContent</dt>
 * <dd>Return snippets of related content that is related to the query, but no more than
 *  this many. Any value greater than EDAM_RELATED_MAX_RELATED_CONTENT will be silently
 *  capped. If you do not set this field, then no related content will be returned.</dd>
 * </dl>
 * 
 * <dt>relatedContentTypes</dt>
 * <dd>Specifies the types of Related Content that should be returned.</dd>
 * </dl>
 */
@interface EDAMRelatedResultSpec : FATObject 
@property (nonatomic, strong) NSNumber * maxNotes; // int32_t
@property (nonatomic, strong) NSNumber * maxNotebooks; // int32_t
@property (nonatomic, strong) NSNumber * maxTags; // int32_t
@property (nonatomic, strong) NSNumber * writableNotebooksOnly; // BOOL
@property (nonatomic, strong) NSNumber * includeContainingNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * includeDebugInfo; // BOOL
@property (nonatomic, strong) NSNumber * maxExperts; // int32_t
@property (nonatomic, strong) NSNumber * maxRelatedContent; // int32_t
@property (nonatomic, strong) NSSet<NSNumber *> * relatedContentTypes;
@end

/*
 * A description of the query which will be used to retrieve search suggestions
 * 
 * <dl>
 * <dt>prefix</dt>
 * <dd>The search prefix for which suggestions will be returned.
 * You must provide a prefix with length between EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MIN
 * and EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MAX
 * </dd>
 * 
 * <dt>contextFilter</dt>
 * <dd>The list of search criteria that will constrain the suggestions.
 * This filter will be used to determine the set of notes within which
 * suggestions should be generated.
 * You must set this if you want to restrict suggestions
 * within a specified context like notebook/tag/stacks etc.
 * Leave this unset to get suggestions across all of
 * the users notes.
 * Below is how the <code>NoteFilter</code> parameters are used:
 * <ul>
 * <li>notebookGuid - if present suggestions will be generated from
 * notes within this notebook only.
 * </li>
 * <li>tagGuids - if present suggestions will be generated from
 * notes that have the specified tags
 * </li>
 * <li>words - The search query string that provides additional restrictive
 * context information.
 * e.g. stack:X or contentClass:X can be specified here to restrict the suggestions
 * to notes within the above context.
 * The string must obey the Evernote Search Grammar
 * <li> timeZone - the zone id for the user to interpret any additional
 * date or times in the queries that do not include desired zone information
 * </li>
 * </ul>
 * Please note: The below parameters of <code>NoteFilter</code> will be ignored:
 * <ul>
 * <li>order</li>
 * <li>ascending</li>
 * <li>emphasized</li>
 * <li>inactive - suggestions will always only be from active notes</li>
 * </ul>
 * </dd>
 * 
 * </dl>
 */
@interface EDAMSearchSuggestionQuery : FATObject 
@property (nonatomic, strong) NSString * prefix;
@property (nonatomic, strong) EDAMNoteFilter * contextFilter;
@end

/*
 * This is a specification of the result of the call to findSearchSuggestions.
 * You can use this to specify how many search suggestions you are seeking.
 * 
 * <dl>
 * <dt>maxTypeAheadSuggestions</dt>
 * <dd>Return no more than this many type ahead suggestions for the specified <code>SearchSuggestionQuery</code>.
 * Any value greater than EDAM_SEARCH_SUGGESTIONS_MAX will be silently capped.
 * If you do not set a value no type ahead suggestions will be provided.
 * </dd>
 * </dl>
 */
@interface EDAMSearchSuggestionResultSpec : FATObject 
@property (nonatomic, strong) NSNumber * maxTypeAheadSuggestions; // int32_t
@end

/*
 * This represents a Search Suggestion that gets returned via the call to findSearchSuggestions
 * 
 * <dl>
 * <dt>suggestionText</dt>
 * <dd>The suggested search text</dd>
 * </dl>
 */
@interface EDAMSearchSuggestion : FATObject 
@property (nonatomic, strong) NSString * suggestionText;
@end

/*
 * The result of calling findSearchSuggestions().
 * Represents lists of returned suggestions
 * 
 * <dl>
 * <dt>typeAheadSuggestions</dt>
 * <dd> A list of suggestions that completes the specified search prefix.
 * The list is ordered in descending order of relevance, the first item in the list
 * being the most relevant.
 * The list will be unset if there are no type ahead suggestions for the
 * specified query
 * </dd>
 * </dl>
 */
@interface EDAMSearchSuggestionResult : FATObject 
@property (nonatomic, strong) NSArray<EDAMSearchSuggestion *> * typeAheadSuggestions;
@end

/*
 * A description of a time zone from the Service time zone database.
 * 
 * <dl>
 * <dt>id</dt>
 * <dd>The time zone database identifier.  You can use this value with
 *     the updateUserSetting method.
 * </dd>
 * <dt>rawUTCOffsetMillis</dt>
 * <dd>The raw offset to add to UTC to get to the time zone's
 *     standard time for the current date.  The value may be negative
 *     and is in milliseconds.
 * </dd>
 * <dt>dstSavingsAdjustmentMillis</dt>
 * <dd>The number of milliseconds to add to standard time to get to daylight
 *     savings time.  This value is for "today" or when daylight savings is
 *     next in effect and not for historical values.
 * </dd>
 * <dt>nextEnterDaylightSavings</dt>
 * <dd>A Timestamp for when, over the coming year, the time zone is entering
 *     daylight savings.
 * </dd>
 * <dt>nextLeaveDaylightSavings</dt>
 * <dd>Similar to nextEnterDaylightSavings, but for when over the coming year
 *     the time zone is next leaving daylight savings.
 * </dd>
 * </dl>
 */
@interface EDAMTimeZone : FATObject 
@property (nonatomic, strong) NSString * id;
@property (nonatomic, strong) NSString * displayName;
@property (nonatomic, strong) NSNumber * rawUTCOffsetMillis; // int32_t
@property (nonatomic, strong) NSNumber * dstSavingsAdjustmentMillis; // int32_t
@property (nonatomic, strong) NSNumber * nextEnterDaylightSavings; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * nextLeaveDaylightSavings; // EDAMTimestamp
@end

/*
 * A specifier that describes a time zone, used by the findTimeZone service
 * method to find time zones in the Service database.  The more information
 * you provide, the more accurate your results will be.
 * 
 * <dl>
 * <dt>id</dt>
 * <dd>The client time zone database identifier.
 * </dd>
 * <dt>rawUTCOffsetMillis</dt>
 * <dd>The raw offset to add to UTC to get to the time zone's
 *     standard time for the current date.  The value may be negative
 *     and is in milliseconds.
 * </dd>
 * <dt>dstSavingsAdjustmentMillis</dt>
 * <dd>The number of milliseconds to add to standard time to get to daylight
 *     savings time.  This value is for "today" or when daylight savings is
 *     next in effect and not for historical values.
 * </dd>
 * <dt>nextEnterDaylightSavings</dt>
 * <dd>A Timestamp for when, over the coming year, the time zone is entering
 *     daylight savings.  The time should be between "now" and around a year
 *     from now.  Keep in mind that folks below the equator have summer when
 *     folks above the equator have winter.  A simple algorithm clients can use
 *     is to simply iterate every 24 hours from "now" seeking a transition into
 *     daylight savings time.
 * </dd>
 * <dt>nextLeaveDaylightSavings</dt>
 * <dd>Similar to nextEnterDaylightSavings, but for when over the coming year
 *     the time zone is next leaving daylight savings.
 * </dd>
 * </dl>
 */
@interface EDAMTimeZoneSpec : FATObject 
@property (nonatomic, strong) NSString * id;
@property (nonatomic, strong) NSNumber * rawUTCOffsetMillis; // int32_t
@property (nonatomic, strong) NSNumber * dstSavingsAdjustmentMillis; // int32_t
@property (nonatomic, strong) NSNumber * nextEnterDaylightSavings; // EDAMTimestamp
@property (nonatomic, strong) NSNumber * nextLeaveDaylightSavings; // EDAMTimestamp
@end

/*
 * A description of what we are searching within a user's contacts data.
 * 
 * You must specify <em>prefix</em>.
 * 
 * <dl>
 * <dt>maxEntries</dt>
 * <dd>Optional. Maximum number of contact entries the service
 *     should return.</dd>
 * 
 * <dt>prefix</dt>
 * <dd>prefix pattern to match contacts name and email.</dd>
 * </dl>
 */
@interface EDAMContactsQuery : FATObject 
@property (nonatomic, strong) NSNumber * maxEntries; // int32_t
@property (nonatomic, strong) NSString * prefix;
@end

/*
 * A description of what we are searching within the business.
 * 
 * filter.notebookGuid must not be specified and filter.words must not contain
 * a "notebook:" identifier.
 * 
 * <dl>
 * <dt>filter</dt>
 * <dd>A NoteFilter that specifies the search criteria.</dd>
 * 
 * <dt>numExperts</dt>
 * <dd>The maximum number of experts to include in the result. 0 indicates no
 *     expertise search will be performed.</dd>
 * </dl>
 * 
 * <dt>includeNotebooks</dt>
 * <dd>Whether to include the full list of matching notebooks in addition to the count.</dd>
 * 
 * <dt>includeNotesCounts</dt>
 * <dd>Whether to include the notes counts.</dd>
 * 
 */
@interface EDAMBusinessQuery : FATObject 
@property (nonatomic, strong) EDAMNoteFilter * filter;
@property (nonatomic, strong) NSNumber * numExperts; // int32_t
@property (nonatomic, strong) NSNumber * includeNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * includeNotesCounts; // BOOL
@end

/*
 * Result of searching the business.
 * 
 * <dl>
 * <dt>totalNotebooks</dt>
 * <dd>The total number of notebooks with a name or description that matched the search query.</dd>
 * 
 * <dt>totalNotesByNotebook</dt>
 * <dd>A mapping from notebook guid to a count of notes which represents the total number
 *     of notes per notebook that matched the search query. This mapping only contains
 *     notebook guids that have at least one matched note. Will only be included if includeNotesCounts
 *     was set to true in the query.</dd>
 * 
 * <dt>experts</dt>
 * <dd>A list of users within the business who have knowledge about the specified query.
 *     An empty list will be returned if numExperts was set to 0 or no experts
 *     were found.</dd>
 * 
 * <dt>matchingNotebooks</dt>
 * <dd>The list of notebooks with a name or description that matched the search query. Will only
 *     be included if includeNotebooks was set to true in the query.</dd>
 * </dl>
 */
@interface EDAMBusinessQueryResult : FATObject 
@property (nonatomic, strong) NSNumber * totalNotebooks; // int32_t
@property (nonatomic, strong) NSDictionary<EDAMGuid,NSNumber *> * totalNotesByNotebook;
@property (nonatomic, strong) NSArray<EDAMUserProfile *> * experts;
@property (nonatomic, strong) NSArray<EDAMNotebook *> * matchingNotebooks;
@end

/*
 * The NoteLockStatus structure encapsulate the lock status for a Note that may be edited
 * by multiple users.
 * 
 * <dl>
 * <dt>noteUpdateSequenceNumber</dt>
 * <dd>The current UpdateSequenceNumber of the Note for which this NoteLockStatus was
 *     requested.</dd>
 * 
 * <dt>lockHolderUserId</dt>
 * <dd>If set, this is the ID of the User who currently holds the lock on the Note for
 *     which this NoteLockStatus was requested. If this is unset the Note is not
 *     locked.</dd>
 * 
 * <dt>lockRenewBy</dt>
 * <dd>If set, this is the time after which the current lock on the Note for which this
 *     NoteLockStatus was requested will expire. If this is unset the Note is not
 *     locked.</dd>
 * 
 * <dt>viewingUserIds</dt>
 * <dd>A list of User IDs corresponding to the viewers of this Note. This list will
 *     include the IDs of all Users on whose behalf a call to getNoteLockStatus(),
 *     acquireNoteLock(), or releaseNoteLock() were called for this Note in the last 30
 *     seconds.</dd>
 * 
 * <dt>viewIdleExpiration</dt>
 * <dd>Gives the length of time, in milliseconds, that the service will consider someone
 *     to be 'viewing' a note after a call to getNoteLockStatus. After this much time
 *     has passed without seeing any more calls to see the status of the same note, the
 *     user is no longer considered to be 'viewing' the note.</dd>
 * 
 * <dt>unknownUsers</dt>
 * <dd>If the 'viewingUserIds' list contains the numeric UserID of any users who are not
 *     directly known to the authenticated user who requested the status information,
 *     then this map will be added to the status structure, and it will include a Contact
 *     record to give information about those unknown people. This will not include
 *     information about any users who are already known by virtue of being in the same
 *     Business, or who are connected via previous Messaging activity.
 *     <br/>
 *     The Contact records in this map may be used verbatim in calls to sendMessage until
 *     Contact.sendMessagePermitExpires, after which they will be rejected by the service
 *     if the caller does not have a direct connection with the recipient.
 *     <br/>
 *     If all of the UserIDs in 'viewingUserIds' are already known to the caller, this
 *     map will be omitted.</dd>
 * 
 * <dt>currentTime<dt>
 * <dd>If set, this will contain the current server timestamp at the time the
 *     NoteLockStatus was generated. When combined with the <code>lockRenewBy</code> field
 *     this allows clients to gauge when a note lock must be renewed, even if the client's
 *     local clock is skewed relative to the service. If this is unset the Note is not
 *     locked.</dd>
 * </dl>
 */
@interface EDAMNoteLockStatus : FATObject 
@property (nonatomic, strong) NSNumber * noteUpdateSequenceNumber; // int32_t
@property (nonatomic, strong) NSNumber * lockHolderUserId; // EDAMUserID
@property (nonatomic, strong) NSNumber * lockRenewBy; // EDAMTimestamp
@property (nonatomic, strong) NSArray<NSNumber *> * viewingUserIds;
@property (nonatomic, strong) NSNumber * viewIdleExpiration; // int32_t
@property (nonatomic, strong) NSDictionary<NSNumber *,EDAMContact *> * unknownUsers;
@property (nonatomic, strong) NSNumber * currentTime; // EDAMTimestamp
@end

/*
 * The result of a call to updateNoteIfUsnMatches, which optionally updates a note
 * based on the current value of the note's update sequence number on the service.
 * 
 * <dl>
 * <dt>note</dt>
 * <dd>Either the current state of the note if <tt>updated</tt> is false or the
 * result of updating the note as would be done via the <tt>updateNote</tt> method.
 * If the note was not updated, you will receive a Note that does not include note
 * content, resources data, resources recognition data, or resources alternate data.
 * You can check for updates to these large objects by checking the Data.bodyHash
 * values and downloading accordingly.</dd>
 * 
 * <dt>updated</dt>
 * <dd>Whether or not the note was updated by the operation.</dd>
 * </dl>
 */
@interface EDAMUpdateNoteIfUsnMatchesResult : FATObject 
@property (nonatomic, strong) EDAMNote * note;
@property (nonatomic, strong) NSNumber * updated; // BOOL
@end

@interface EDAMShareRelationshipRestrictions : FATObject 
@property (nonatomic, strong) NSNumber * noSetReadOnly; // BOOL
@property (nonatomic, strong) NSNumber * noSetReadPlusActivity; // BOOL
@property (nonatomic, strong) NSNumber * noSetModify; // BOOL
@property (nonatomic, strong) NSNumber * noSetFullAccess; // BOOL
@end

/*
 * Describes an invitation to a person to use their Evernote
 * credentials to become a member of a notebook.
 * 
 * <dl>
 * <dt>displayName</dt>
 * <dd>The string that clients should show to users to represent this
 * invitation.</dd>
 * 
 * <dt>recipientUserIdentity</dt>
 * <dd>Identifies the recipient of the invitation. The user identity
 * type can be either EMAIL or IDENTITYID, depending on whether the
 * invitation was created using the classic notebook sharing APIs or
 * the new identity-based notebook sharing APIs.
 * </dd>
 * 
 * <dt>privilege</dt>
 * <dd>The privilege level at which the member will be joined, if it
 * turns out that the member is not already joined at a higher level.
 * Note that the <tt>identity</tt> field may not uniquely identify an
 * Evernote User ID, and so we won't know until the invitation is
 * redeemed whether or not the recipient already has privilege.</dd>
 * 
 * <dt>sharerUserId</dt>
 * <dd>The user id of the user who most recently shared this notebook
 * to this identity. This field is used by the service to convey information
 * to the user, so clients should treat it as read-only.</dd>
 * </dl>
 */
@interface EDAMInvitationShareRelationship : FATObject 
@property (nonatomic, strong) NSString * displayName;
@property (nonatomic, strong) EDAMUserIdentity * recipientUserIdentity;
@property (nonatomic, strong) NSNumber * privilege; // int
@property (nonatomic, strong) NSNumber * sharerUserId; // EDAMUserID
@end

/*
 * Describes the association between a Notebook and an Evernote User who is
 * a member of that notebook.
 * 
 * <dl>
 * <dt>displayName</dt>
 * <dd>The string that clients should show to users to represent this
 * member.</dd>
 * 
 * <dt>recipientUserId</dt>
 * <dd>The Evernote User ID of the recipient of this notebook share.
 * </dd>
 * 
 * <dt>bestPrivilege</dt>
 * <dd>The privilege at which the member can access the notebook,
 * which is the best privilege granted either individually or to a
 * group to which a member belongs, such as a business.  This field is
 * used by the service to convey information to the user, so clients
 * should treat it as read-only.</dd>
 * 
 * <dt>individualPrivilege</dt>
 * <dd>The individually granted privilege for the member, which does
 * not take GROUP privileges into account.  This value may be unset if
 * only a group-assigned privilege has been granted to the member.
 * This value can be managed by others with sufficient rights using
 * the manageNotebookShares method.  The valid values that clients
 * should present to users for selection are given via the the
 * 'restrictions' field.</dd>
 * 
 * <dt>restrictions</dt>
 * <dd>The restrictions on which privileges may be individually
 * assigned to the recipient of this share relationship.</dd>
 * 
 * <dt>sharerUserId</dt>
 * <dd>The user id of the user who most recently shared the notebook
 * to this user. This field is currently unset for a MemberShareRelationship
 * created by joining a notebook that has been published to the business
 * (MemberShareRelationships where the individual privilege is unset).
 * This field is used by the service to convey information to the user, so
 * clients should treat it as read-only.
 * </dd>
 * </dl>
 */
@interface EDAMMemberShareRelationship : FATObject 
@property (nonatomic, strong) NSString * displayName;
@property (nonatomic, strong) NSNumber * recipientUserId; // EDAMUserID
@property (nonatomic, strong) NSNumber * bestPrivilege; // int
@property (nonatomic, strong) NSNumber * individualPrivilege; // int
@property (nonatomic, strong) EDAMShareRelationshipRestrictions * restrictions;
@property (nonatomic, strong) NSNumber * sharerUserId; // EDAMUserID
@end

/*
 * Captures a collection of share relationships for a notebook, for
 * example, as returned by the getNotebookShares method.  The share
 * relationships fall into two broad categories: members, and
 * invitations that can be used to become members.
 * 
 * <dl>
 * <dt>invitations</dt>
 * <dd>A list of open invitations that can be redeemed into
 * memberships to the notebook.</dd>
 * 
 * <dt>memberships</dt>
 * <dd>A list of memberships of the notebook.  A member is identified
 * by their Evernote UserID and has rights to access the
 * notebook.</dd>
 * 
 * <dt>invitationRestrictions</dt>
 * <dd>The restrictions on what privileges may be granted to invitees
 * to this notebook. These restrictions may be specific to the calling
 * user or to the notebook itself. They represent the
 * union of all possible invite cases, so it is possible that once the
 * recipient of the invitation has been identified by the service, such
 * as by a business auto-join, the actual assigned privilege may change.
 * </dd>
 * </dl>
 */
@interface EDAMShareRelationships : FATObject 
@property (nonatomic, strong) NSArray<EDAMInvitationShareRelationship *> * invitations;
@property (nonatomic, strong) NSArray<EDAMMemberShareRelationship *> * memberships;
@property (nonatomic, strong) EDAMShareRelationshipRestrictions * invitationRestrictions;
@end

/*
 * A structure that captures parameters used by clients to manage the
 * shares for a given notebook via the manageNotebookShares method.
 * 
 * <dl>
 * <dt>notebookGuid</dt>
 * <dd>The GUID of the notebook whose shares are being managed.</dd>
 * 
 * <dt>inviteMessage</dt>
 * <dd>If the service sends a message to invitees, this parameter will
 * be used to form the actual message that is sent.</dd>
 * 
 * <dt>membershipsToUpdate</dt>
 * <dd>The list of existing memberships to update.  This field is not
 * intended to be the full set of memberships for the notebook and
 * should only include those already-existing memberships that you
 * actually want to change.  If you want to remove shares, see the
 * unshares fields.  If you want to create a membership,
 * i.e. auto-join a business user, you can do this via the
 * invitationsToCreateOrUpdate field using an Evernote UserID of a
 * fellow business member (the created invitation is automatically
 * joined by the service, so the client is creating an
 * invitation, not a membership).</dd>
 * 
 * <dt>invitationsToCreateOrUpdate</dt>
 * <dd>The list of invitations to update, as matched by the identity
 * field of the InvitationShareRelationship instances, or to create if
 * an existing invitation does not exist.  This field is not intended
 * to be the full set of invitations on the notebook and should only
 * include those invitations that you wish to create or update.  Note
 * that your invitation could convert into a membership via a
 * service-supported auto-join operation.  This happens, for example,
 * when you use an invitation with an Evernote UserID type for a
 * recipient who is a member of the business to which the notebook
 * belongs.  Note that to discover the user IDs for business members,
 * the sharer must also be part of the business.</dd>
 * 
 * <dt>unshares</dt>
 * <dd>The list of share relationships to expunge from the service.
 * If the user identity is for an Evernote UserID, then memberships will
 * be removed. If it's an e-mail, then e-mail based shared notebook
 * invitations will be removed. If it's for an Identity ID, then
 * any invitations that match the identity (by identity ID or user ID or
 * e-mail for legacy invitations) will be removed.</dd>
 * </dl>
 */
@interface EDAMManageNotebookSharesParameters : FATObject 
@property (nonatomic, strong) NSString * notebookGuid;
@property (nonatomic, strong) NSString * inviteMessage;
@property (nonatomic, strong) NSArray<EDAMMemberShareRelationship *> * membershipsToUpdate;
@property (nonatomic, strong) NSArray<EDAMInvitationShareRelationship *> * invitationsToCreateOrUpdate;
@property (nonatomic, strong) NSArray<EDAMUserIdentity *> * unshares;
@end

/*
 * A structure to capture certain errors that occurred during a call
 * to manageNotebookShares.  That method can be run best-effort,
 * meaning that some change requests can be applied while others fail.
 * Note that some errors such as system errors will still fail the
 * entire transaction regardless of running best effort.  When some
 * change requests do not succeed, the error conditions are captured
 * in instances of this class, captured by the identity of the share
 * relationship and one of the exception fields.
 * 
 * <dl>
 * <dt>userIdentity</dt>
 * <dd>The identity of the share relationship whose update encountered
 * an error.</dd>
 * 
 * <dt>userException</dt>
 * <dd>If the error is represented as an EDAMUserException that would
 * have otherwise been thrown without best-effort execution.  Only one
 * exception field will be set.</dd>
 * 
 * <dt>notFoundException</dt>
 * <dd>If the error is represented as an EDAMNotFoundException that would
 * have otherwise been thrown without best-effort execution.  Only one
 * exception field will be set.</dd>
 * </dl>
 */
@interface EDAMManageNotebookSharesError : FATObject 
@property (nonatomic, strong) EDAMUserIdentity * userIdentity;
@property (nonatomic, strong) EDAMUserException * userException;
@property (nonatomic, strong) EDAMNotFoundException * notFoundException;
@end

/*
 * The return value of a call to the manageNotebookShares method.
 * 
 * <dl>
 * <dt>errors</dt>
 * <dd>If the method completed without throwing exceptions, some errors
 * might still have occurred, and in that case, this field will contain
 * the list of those errors the occurred.
 * </dd>
 * </dl>
 */
@interface EDAMManageNotebookSharesResult : FATObject 
@property (nonatomic, strong) NSArray<EDAMManageNotebookSharesError *> * errors;
@end

/*
 * A structure used to share a note with one or more recipients at a given privilege.
 * 
 * <dl>
 *   <dt>noteGuid</dt>
 *   <dd>The GUID of the note.</dd>
 * 
 *   <dt>recipientThreadId</dt>
 *   <dd>The recipients of the note share specified as a messaging thread ID. If you
 *       have an existing messaging thread to share the note with, specify its ID
 *       here instead of recipientContacts in order to properly support defunct
 *       identities. The sharer must be a participant of the thread. Either this
 *       field or recipientContacts must be set.</dd>
 * 
 *   <dt>recipientContacts</dt>
 *   <dd>The recipients of the note share specified as a list of contacts. This should
 *       only be set if the sharing takes place before the thread is created. Use
 *       recipientThreadId instead when sharing with an existing thread. Either this
 *       field or recipientThreadId must be set.</dd>
 * 
 *   <dt>privilege</dt>
 *   <dd>The privilege level to be granted.</dd>
 * </dl>
 */
@interface EDAMSharedNoteTemplate : FATObject 
@property (nonatomic, strong) EDAMGuid noteGuid;
@property (nonatomic, strong) NSNumber * recipientThreadId; // EDAMMessageThreadID
@property (nonatomic, strong) NSArray<EDAMContact *> * recipientContacts;
@property (nonatomic, strong) NSNumber * privilege; // int
@end

/*
 * A structure used to share a notebook with one or more recipients at a given privilege.
 * 
 * <dl>
 *   <dt>notebookGuid</dt>
 *   <dd>The GUID of the notebook.</dd>
 * 
 *   <dt>recipientThreadId</dt>
 *   <dd>The recipients of the notebook share specified as a messaging thread ID. If you
 *       have an existing messaging thread to share the note with, specify its ID
 *       here instead of recipientContacts in order to properly support defunct
 *       identities. The sharer must be a participant of the thread. Either this field
 *       or recipientContacts must be set.</dd>
 * 
 *   <dt>recipientContacts</dt>
 *   <dd>The recipients of the notebook share specified as a list of contacts. This should
 *       only be set if the sharing takes place before the thread is created. Use
 *       recipientThreadId instead when sharing with an existing thread. Either this
 *       field or recipientThreadId must be set.</dd>
 * 
 *   <dt>privilege</dt>
 *   <dd>The privilege level to be granted.</dd>
 * </dl>
 */
@interface EDAMNotebookShareTemplate : FATObject 
@property (nonatomic, strong) EDAMGuid notebookGuid;
@property (nonatomic, strong) NSNumber * recipientThreadId; // EDAMMessageThreadID
@property (nonatomic, strong) NSArray<EDAMContact *> * recipientContacts;
@property (nonatomic, strong) NSNumber * privilege; // int
@end

/*
 * A structure containing the results of a call to createOrUpdateNotebookShares.
 * 
 * <dl>
 *   <dt>updateSequenceNum</dt>
 *   <dd>The USN of the notebook after the call.</dd>
 * 
 *   <dt>matchingShares</dt>
 *   <dd>A list of SharedNotebook records that match the desired recipients. These
 *       records may have been either created or updated by the call to
 *       createOrUpdateNotebookShares, or they may have been at the desired privilege
 *       privilege level prior to the call.</dd>
 * </dl>
 */
@interface EDAMCreateOrUpdateNotebookSharesResult : FATObject 
@property (nonatomic, strong) NSNumber * updateSequenceNum; // int32_t
@property (nonatomic, strong) NSArray<EDAMSharedNotebook *> * matchingShares;
@end

/*
 * This structure is used by the service to communicate to clients, via
 * getNoteShareRelationships, which privilege levels are assignable to the
 * target of a note share relationship.
 * 
 * <dl>
 * <dt>noSetReadNote</dt>
 * <dd>This value is true if the user is not allowed to set the privilege
 * level to SharedNotePrivilegeLevel.READ_NOTE.</dd>
 * 
 * <dt>noSetModifyNote</dt>
 * <dd>This value is true if the user is not allowed to set the privilege
 * level to SharedNotePrivilegeLevel.MODIFY_NOTE.</dd>
 * 
 * <dt>noSetFullAccess</dt>
 * <dd>This value is true if the user is not allowed to set the
 * privilege level to SharedNotePrivilegeLevel.FULL_ACCESS.</dd>
 * </dl>
 */
@interface EDAMNoteShareRelationshipRestrictions : FATObject 
@property (nonatomic, strong) NSNumber * noSetReadNote; // BOOL
@property (nonatomic, strong) NSNumber * noSetModifyNote; // BOOL
@property (nonatomic, strong) NSNumber * noSetFullAccess; // BOOL
@end

/*
 * Describes the association between a Note and an Evernote User who is
 * a member of that note.
 * 
 * <dl>
 * <dt>displayName</dt>
 * <dd>The string that clients should show to users to represent this
 * member.</dd>
 * 
 * <dt>recipientUserId</dt>
 * <dd>The Evernote UserID of the user who is a member to the note.</dd>
 * 
 * <dt>privilege</dt>
 * <dd>The privilege at which the member can access the note,
 * which is the best privilege granted to the user across all of their
 * individual shares for this note. This field is used by the service
 * to convey information to the user, so clients should treat it as
 * read-only.</dd>
 * 
 * <dt>restrictions</dt>
 * <dd>The restrictions on which privileges may be individually
 * assigned to the recipient of this share relationship. This field
 * is used by the service to convey information to the user, so
 * clients should treat it as read-only.</dd>
 * 
 * <dt>sharerUserId</dt>
 * <dd>The user id of the user who most recently shared the note with
 * this user. This field is used by the service to convey information
 * to the user, so clients should treat it as read-only.</dd>
 * </dl>
 */
@interface EDAMNoteMemberShareRelationship : FATObject 
@property (nonatomic, strong) NSString * displayName;
@property (nonatomic, strong) NSNumber * recipientUserId; // EDAMUserID
@property (nonatomic, strong) NSNumber * privilege; // int
@property (nonatomic, strong) EDAMNoteShareRelationshipRestrictions * restrictions;
@property (nonatomic, strong) NSNumber * sharerUserId; // EDAMUserID
@end

/*
 * Describes an invitation to a person to use their Evernote credentials
 * to gain access to a note belonging to another user.
 * 
 * <dl>
 * <dt>displayName</dt>
 * <dd>The string that clients should show to users to represent this
 * invitation.</dd>
 * 
 * <dt>recipientIdentityId</dt>
 * <dd>Identifies the identity of the invitation recipient. Once the
 * identity has been claimed by an Evernote user and they have accessed
 * the note at least once, the invitation will be used up and will no
 * longer be returned by the service to clients. Instead, that recipient
 * will be included in the list of NoteMemberShareRelationships.</dd>
 * 
 * <dt>privilege</dt>
 * <dd>The privilege level that the recipient will be granted when they
 * accept this invitation. If the user already has a higher privilege to
 * access this note then this will not affect the recipient's privileges.</dd>
 * 
 * <dt>sharerUserId</dt>
 * <dd>The user id of the user who most recently shared this note to this
 * recipient. This field is used by the service to convey information
 * to the user, so clients should treat it as read-only.</dd>
 */
@interface EDAMNoteInvitationShareRelationship : FATObject 
@property (nonatomic, strong) NSString * displayName;
@property (nonatomic, strong) NSNumber * recipientIdentityId; // EDAMIdentityID
@property (nonatomic, strong) NSNumber * privilege; // int
@property (nonatomic, strong) NSNumber * sharerUserId; // EDAMUserID
@end

/*
 * Captures a collection of share relationships for a single note,
 * for example, as returned by the getNoteShares method. The share
 * relationships fall into two broad categories: members, and
 * invitations that can be used to become members.
 * 
 * <dl>
 * <dt>invitations</dt>
 * <dd>A list of open invitations that can be redeemed into
 * memberships to the note.</dd>
 * 
 * <dt>memberships</dt>
 * <dd>A list of memberships of the noteb. A member is identified
 * by their Evernote UserID and has rights to access the
 * note.</dd>
 * 
 * <dt>restrictions</dt>
 * <dd>The restrictions on which privileges may be assigned to the recipient
 * of an open invitation. These restrictions only apply to invitations;
 * restrictions on memberships are specified on the NoteMemberShareRelationship.
 * This field is used by the service to convey information to the user, so
 * clients should treat it as read-only.</dd>
 * 
 * </dl>
 */
@interface EDAMNoteShareRelationships : FATObject 
@property (nonatomic, strong) NSArray<EDAMNoteInvitationShareRelationship *> * invitations;
@property (nonatomic, strong) NSArray<EDAMNoteMemberShareRelationship *> * memberships;
@property (nonatomic, strong) EDAMNoteShareRelationshipRestrictions * invitationRestrictions;
@end

/*
 * Captures parameters used by clients to manage the shares for a given
 * note via the manageNoteShares function. This is used only to manage
 * the existing memberships and invitations for a note. To invite a new
 * recipient, use NoteStore.createOrUpdateSharedNotes.
 * 
 * The only field of an existing membership or invitation that can be
 * updated by this function is the share privilege.
 * 
 * <dl>
 *   <dt>noteGuid</dt>
 *   <dd>The GUID of the note whose shares are being managed.</dd>
 * 
 *   <dt>membershipsToUpdate</dt>
 *   <dd>A list of existing memberships to update. This field is not
 *     meant to be the full set of memberships for the note. Clients
 *     should only include those existing memberships that they wish
 *     to modify. To remove an existing membership, see the unshares
 *     field.</dd>
 * 
 *   <dt>invitationsToUpdate</dt>
 *   <dd>The list of outstanding invitations to update, as matched by the
 *     identity field of the NoteInvitationShareRelatioship instances.
 *     This field is not meant to be the full set of invitations for the
 *     note. Clients should only include those existing invitations that
 *     they wish to modify.</dd>
 * 
 *   <dt>membershipsToUnshare</dt>
 *   <dd>A list of existing memberships to expunge from the service.</dd>
 * 
 *   <dt>invitationsToUnshare</dt>
 *   <dd>A list of outstanding invitations to expunge from the service.</dd>
 * </dl>
 */
@interface EDAMManageNoteSharesParameters : FATObject 
@property (nonatomic, strong) NSString * noteGuid;
@property (nonatomic, strong) NSArray<EDAMNoteMemberShareRelationship *> * membershipsToUpdate;
@property (nonatomic, strong) NSArray<EDAMNoteInvitationShareRelationship *> * invitationsToUpdate;
@property (nonatomic, strong) NSArray<NSNumber *> * membershipsToUnshare;
@property (nonatomic, strong) NSArray<NSNumber *> * invitationsToUnshare;
@end

/*
 * Captures errors that occur during a call to manageNoteShares. That
 * function can be run best-effort, meaning that some change requests can
 * be applied while others fail. Note that some errors such as system
 * exceptions may still cause the entire call to fail.
 * 
 * Only one of the two ID fields will be set on a given error.
 * 
 * Only one of the two exception fields will be set on a given error.
 * 
 * <dl>
 *   <dt>identityID</dt>
 *   <dd>The identity ID of an outstanding invitation that was not updated
 *     due to the error.</dd>
 * 
 *   <dt>userID</dt>
 *   <dd>The user ID of an existing membership that was not updated due
 *     to the error.</dd>
 * 
 *   <dt>userException</dt>
 *   <dd>If the error is represented as an EDAMUserException that would
 *     have otherwise been thrown without best-effort execution.</dd>
 * 
 *   <dt>notFoundException</dt>
 *   <dd>If the error is represented as an EDAMNotFoundException that
 *     would have otherwise been thrown without best-effort execution.
 *     The identifier field of the exception will be either "Identity.id"
 *     or "User.id", indicating that no existing share could be found for
 *     the specified recipient.</dd>
 * </dl>
 */
@interface EDAMManageNoteSharesError : FATObject 
@property (nonatomic, strong) NSNumber * identityID; // EDAMIdentityID
@property (nonatomic, strong) NSNumber * userID; // EDAMUserID
@property (nonatomic, strong) EDAMUserException * userException;
@property (nonatomic, strong) EDAMNotFoundException * notFoundException;
@end

/*
 * The return value of a call to the manageNoteShares function.
 * 
 * <dl>
 *   <dt>errors</dt>
 *   <dd>If the call succeeded without throwing an exception, some errors
 *     might still have occurred. In that case, this field will contain the
 *     list of errors.</dd>
 * </dl>
 */
@interface EDAMManageNoteSharesResult : FATObject 
@property (nonatomic, strong) NSArray<EDAMManageNoteSharesError *> * errors;
@end

/*
 * The record about a user's search behaviour, which includes information about
 * the search query, the GUID of the note the user has selected.
 * 
 * <dl>
 *   <dt>userQuery</dt>
 *   <dd>The original query string from the user. The query string in NoteFilter is a
 *   preprocessed version.</dd>
 * 
 *   <dt>noteFilter</dt>
 *   <dd>NoteFilter which contains information about a search query from the user</dd>
 * 
 *   <dt>searchScope</dt>
 *   <dd>The scope of the search: personal notes or business notes.</dd>
 * 
 *   <dt>searchTime</dt>
 *   <dd>Timestamp, in miliseconds since the epoch, at when the user conducted
 *     the search.</dd>
 * 
 *   <dt>selectTime</dt>
 *   <dd>Timestamp, in miliseconds since the epoch, at when the user selected
 *     the note to read. If no selection from the user is detected (i.e. the user does
 *     not click any notes from the search result list), use the searchTime value.</dd>
 * 
 *   <dt>selectedNoteGUID</dt>
 *   <dd>The GUID of the note, which is selected by the user after the
 *     search. If no selection from the user is detected (i.e. the user does not click
 *     any notes from the search result list), we assume the user accepts
 *     the first note from the search results, which is shown automatically.</dd>
 * 
 *   <dt>noteRank</dt>
 *   <dd>The rank of the note, which is selected by the user. If it is the first note,
 *     the rank is 1, and so on. If the client automatically selects the first note
 *     (e.g. Windows, Mac, and Web clients), a rank of 1 should be returned. The
 *     server will handle the logic of deciding whether this note is automatically
 *     selected or not.</dd>
 * 
 *   <dt>noteCount</dt>
 *   <dd>The number of notes returned for this search.</dd>
 * </dl>
 */
@interface EDAMSearchRecord : FATObject 
@property (nonatomic, strong) NSString * userQuery;
@property (nonatomic, strong) EDAMNoteFilter * noteFilter;
@property (nonatomic, strong) NSNumber * searchScope; // int
@property (nonatomic, strong) NSNumber * searchTime; // int64_t
@property (nonatomic, strong) NSString * selectedNoteGUID;
@property (nonatomic, strong) NSNumber * selectTime; // int64_t
@property (nonatomic, strong) NSNumber * noteRank; // int32_t
@property (nonatomic, strong) NSNumber * noteCount; // int32_t
@end

/*
 * Information sent from clients to the server for logging
 * 
 * <dl>
 *   <dt>searchRecord</dt>
 *   <dd>A search record, as defined in SearchRecord.</dd>
 * </dl>
 */
@interface EDAMLogRequest : FATObject 
@property (nonatomic, strong) EDAMSearchRecord * searchRecord;
@end

/*
 * Response from the server after calling LogRequest.
 * 
 * It is empty currently, because we do not need any response from the server for now.
 * However, we add the response support for potential future need.
 */
@interface EDAMLogResponse : FATObject 
@end

@protocol EDAMNoteStore <NSObject>
/*
 * Asks the NoteStore to provide information about the status of the user
 * account corresponding to the provided authentication token.
 */
- (EDAMSyncState *) getSyncState: (NSString *) authenticationToken;

/*
 * Asks the NoteStore to provide information about the status of the user
 * account corresponding to the provided authentication token.
 * This version of 'getSyncState' allows the client to upload coarse-
 * grained usage metrics to the service.
 * 
 * @param clientMetrics  see the documentation of the ClientUsageMetrics
 *   structure for an explanation of the fields that clients can pass to
 *   the service.
 */
- (EDAMSyncState *) getSyncStateWithMetrics: (NSString *) authenticationToken clientMetrics: (EDAMClientUsageMetrics *) clientMetrics;

/*
 * DEPRECATED - use getFilteredSyncChunk.
 */
- (EDAMSyncChunk *) getSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

/*
 * Asks the NoteStore to provide the state of the account in order of
 * last modification.  This request retrieves one block of the server's
 * state so that a client can make several small requests against a large
 * account rather than getting the entire state in one big message.
 * This call gives fine-grained control of the data that will
 * be received by a client by omitting data elements that a client doesn't
 * need. This may reduce network traffic and sync times.
 * 
 * @param afterUSN
 *   The client can pass this value to ask only for objects that
 *   have been updated after a certain point.  This allows the client to
 *   receive updates after its last checkpoint rather than doing a full
 *   synchronization on every pass.  The default value of "0" indicates
 *   that the client wants to get objects from the start of the account.
 * 
 * @param maxEntries
 *   The maximum number of modified objects that should be
 *   returned in the result SyncChunk.  This can be used to limit the size
 *   of each individual message to be friendly for network transfer.
 * 
 * @param filter
 *   The caller must set some of the flags in this structure to specify which
 *   data types should be returned during the synchronization.  See
 *   the SyncChunkFilter structure for information on each flag.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "afterUSN" - if negative
 *   </li>
 *   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
 *   </li>
 * </ul>
 */
- (EDAMSyncChunk *) getFilteredSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter;

/*
 * Asks the NoteStore to provide information about the status of a linked
 * notebook that has been shared with the caller, or that is public to the
 * world.
 * This will return a result that is similar to getSyncState, but may omit
 * SyncState.uploaded if the caller doesn't have permission to write to
 * the linked notebook.
 * 
 * This function must be called on the shard that owns the referenced
 * notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
 * same as LinkedNotebook.shardId.)
 * 
 * @param authenticationToken
 *   This should be an authenticationToken for the guest who has received
 *   the invitation to the share.  (I.e. this should not be the result of
 *   NoteStore.authenticateToSharedNotebook)
 * 
 * @param linkedNotebook
 *   This structure should contain identifying information and permissions
 *   to access the notebook in question.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
 *       populated with the current username of the owner of the notebook for which
 *       you are obtaining sync state.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
 *       correspond to a current user on the service.
 *   </li>
 * </ul>
 * 
 * @throws SystemException <ul>
 *   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
 *       user whose account is on a shard other than that on which this method was
 *       invoked.
 *   </li>
 * </ul>
 */
- (EDAMSyncState *) getLinkedNotebookSyncState: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

/*
 * Asks the NoteStore to provide information about the contents of a linked
 * notebook that has been shared with the caller, or that is public to the
 * world.
 * This will return a result that is similar to getSyncChunk, but will only
 * contain entries that are visible to the caller.  I.e. only that particular
 * Notebook will be visible, along with its Notes, and Tags on those Notes.
 * 
 * This function must be called on the shard that owns the referenced
 * notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
 * same as LinkedNotebook.shardId.)
 * 
 * @param authenticationToken
 *   This should be an authenticationToken for the guest who has received
 *   the invitation to the share.  (I.e. this should not be the result of
 *   NoteStore.authenticateToSharedNotebook)
 * 
 * @param linkedNotebook
 *   This structure should contain identifying information and permissions
 *   to access the notebook in question.  This must contain the valid fields
 *   for either a shared notebook (e.g. shareKey)
 *   or a public notebook (e.g. username, uri)
 * 
 * @param afterUSN
 *   The client can pass this value to ask only for objects that
 *   have been updated after a certain point.  This allows the client to
 *   receive updates after its last checkpoint rather than doing a full
 *   synchronization on every pass.  The default value of "0" indicates
 *   that the client wants to get objects from the start of the account.
 * 
 * @param maxEntries
 *   The maximum number of modified objects that should be
 *   returned in the result SyncChunk.  This can be used to limit the size
 *   of each individual message to be friendly for network transfer.
 *   Applications should not request more than 256 objects at a time,
 *   and must handle the case where the service returns less than the
 *   requested number of objects in a given request even though more
 *   objects are available on the service.
 * 
 * @param fullSyncOnly
 *   If true, then the client only wants initial data for a full sync.
 *   In this case, the service will not return any expunged objects,
 *   and will not return any Resources, since these are also provided
 *   in their corresponding Notes.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "afterUSN" - if negative
 *   </li>
 *   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "LinkedNotebook" - if the provided information doesn't match any
 *     valid notebook
 *   </li>
 *   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
 *     valid notebook
 *   </li>
 *   <li> "SharedNotebook.id" - if the provided information indicates a
 *      shared notebook that no longer exists
 *   </li>
 * </ul>
 */
- (EDAMSyncChunk *) getLinkedNotebookSyncChunk: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

/*
 * Returns a list of all of the notebooks in the account.
 */
- (NSArray<EDAMNotebook *> *) listNotebooks: (NSString *) authenticationToken;

/*
 * Returns a list of all the notebooks in a business that have the Notebook.published
 * flag set to true, regardless of whether the user has joined them.
 * 
 * @param authenticationToken A business authentication token obtained by calling
 *   UserStore.authenticateToBusiness.
 * 
 * @throws EDAMUserException <ul>
 *   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
 *     business auth token.</li>
 * </ul>
 */
- (NSArray<EDAMNotebook *> *) listPublishedBusinessNotebooks: (NSString *) authenticationToken;

/*
 * Returns a list of all the notebooks in a business that the user has permission to access,
 * regardless of whether the user has joined them. This includes notebooks that have been shared
 * with the entire business as well as notebooks that have been shared directly with the user.
 * 
 * @param authenticationToken A business authentication token obtained by calling
 *   UserStore.authenticateToBusiness.
 * 
 * @throws EDAMUserException <ul>
 *   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
 *     business auth token.</li>
 * </ul>
 */
- (NSArray<EDAMNotebook *> *) listAccessibleBusinessNotebooks: (NSString *) authenticationToken;

/*
 * Returns the current state of the notebook with the provided GUID.
 * The notebook may be active or deleted (but not expunged).
 * 
 * @param guid
 *   The GUID of the notebook to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - tag not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMNotebook *) getNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns the notebook that should be used to store new notes in the
 * user's account when no other notebooks are specified.
 */
- (EDAMNotebook *) getDefaultNotebook: (NSString *) authenticationToken;

/*
 * Asks the service to make a notebook with the provided name.
 * 
 * @param notebook
 *   The desired fields for the notebook must be provided on this
 *   object.  The name of the notebook must be set, and either the 'active'
 *   or 'defaultNotebook' fields may be set by the client at creation.
 *   If a notebook exists in the account with the same name (via
 *   case-insensitive compare), this will throw an EDAMUserException.
 * 
 * @return
 *   The newly created Notebook.  The server-side GUID will be
 *   saved in this object's 'guid' field.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
 *   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
 *   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
 *   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
 *   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
 *   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
 *   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
 *   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
 *   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
 *        is set to 'true' for a Notebook that is not owned by the user identified by
 *        the passed authenticationToken.</li>
 *   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
 * </ul>
 */
- (EDAMNotebook *) createNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

/*
 * Submits notebook changes to the service.  The provided data must include
 * the notebook's guid field for identification.
 * 
 * @param notebook
 *   The notebook object containing the requested changes.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
 *   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
 *   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
 *   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
 *   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
 *   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
 *   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
 *   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
 *   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
 *        is set to 'true' for a Notebook that is not owned by the user identified by
 *        the passed authenticationToken.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) updateNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

/*
 * Permanently removes the notebook from the user's account.
 * After this action, the notebook is no longer available for undeletion, etc.
 * If the notebook contains any Notes, they will be moved to the current
 * default notebook and moved into the trash (i.e. Note.active=false).
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param guid
 *   The GUID of the notebook to delete.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
 *   </li>
 *   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
 *   </li>
 *   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
 *   </li>
 * </ul>
 */
- (int32_t) expungeNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns a list of the tags in the account.  Evernote does not support
 * the undeletion of tags, so this will only include active tags.
 */
- (NSArray<EDAMTag *> *) listTags: (NSString *) authenticationToken;

/*
 * Returns a list of the tags that are applied to at least one note within
 * the provided notebook.  If the notebook is public, the authenticationToken
 * may be ignored.
 * 
 * @param notebookGuid
 *    the GUID of the notebook to use to find tags
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - notebook not found by GUID
 *   </li>
 * </ul>
 */
- (NSArray<EDAMTag *> *) listTagsByNotebook: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid;

/*
 * Returns the current state of the Tag with the provided GUID.
 * 
 * @param guid
 *   The GUID of the tag to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Tag.guid" - tag not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMTag *) getTag: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Asks the service to make a tag with a set of information.
 * 
 * @param tag
 *   The desired list of fields for the tag are specified in this
 *   object.  The caller must specify the tag name, and may provide
 *   the parentGUID.
 * 
 * @return
 *   The newly created Tag.  The server-side GUID will be
 *   saved in this object.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
 *   </li>
 *   <li> DATA_CONFLICT "Tag.name" - name already in use
 *   </li>
 *   <li> LIMIT_REACHED "Tag" - at max number of tags
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Tag.parentGuid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMTag *) createTag: (NSString *) authenticationToken tag: (EDAMTag *) tag;

/*
 * Submits tag changes to the service.  The provided data must include
 * the tag's guid field for identification.  The service will apply
 * updates to the following tag fields:  name, parentGuid
 * 
 * @param tag
 *   The tag object containing the requested changes.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
 *   </li>
 *   <li> DATA_CONFLICT "Tag.name" - name already in use
 *   </li>
 *   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
 *   </li>
 *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Tag.guid" - tag not found, by GUID
 *   </li>
 *   <li> "Tag.parentGuid" - parent not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) updateTag: (NSString *) authenticationToken tag: (EDAMTag *) tag;

/*
 * Removes the provided tag from every note that is currently tagged with
 * this tag.  If this operation is successful, the tag will still be in
 * the account, but it will not be tagged on any notes.
 * 
 * This function is not indended for use by full synchronizing clients, since
 * it does not provide enough result information to the client to reconcile
 * the local state without performing a follow-up sync from the service.  This
 * is intended for "thin clients" that need to efficiently support this as
 * a UI operation.
 * 
 * @param guid
 *   The GUID of the tag to remove from all notes.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Tag.guid" - tag not found, by GUID
 *   </li>
 * </ul>
 */
- (void) untagAll: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Permanently deletes the tag with the provided GUID, if present.
 * <p/>
 * NOTE: This function is not generally available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param guid
 *   The GUID of the tag to delete.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Tag.guid" - tag not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) expungeTag: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns a list of the searches in the account.  Evernote does not support
 * the undeletion of searches, so this will only include active searches.
 */
- (NSArray<EDAMSavedSearch *> *) listSearches: (NSString *) authenticationToken;

/*
 * Returns the current state of the search with the provided GUID.
 * 
 * @param guid
 *   The GUID of the search to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
 *   </li>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "SavedSearch.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMSavedSearch *) getSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Asks the service to make a saved search with a set of information.
 * 
 * @param search
 *   The desired list of fields for the search are specified in this
 *   object. The caller must specify the name and query for the
 *   search, and may optionally specify a search scope.
 *   The SavedSearch.format field is ignored by the service.
 * 
 * @return
 *   The newly created SavedSearch.  The server-side GUID will be
 *   saved in this object.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
 *   </li>
 *   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
 *   </li>
 *   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
 *   </li>
 * </ul>
 */
- (EDAMSavedSearch *) createSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

/*
 * Submits search changes to the service. The provided data must include
 * the search's guid field for identification. The service will apply
 * updates to the following search fields: name, query, and scope.
 * 
 * @param search
 *   The search object containing the requested changes.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
 *   </li>
 *   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
 *   </li>
 *   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "SavedSearch.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) updateSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

/*
 * Permanently deletes the saved search with the provided GUID, if present.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param guid
 *   The GUID of the search to delete.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
 *   </li>
 *   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "SavedSearch.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) expungeSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * DEPRECATED. Use findNotesMetadata.
 */
- (EDAMNoteList *) findNotes: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes;

/*
 * Finds the position of a note within a sorted subset of all of the user's
 * notes. This may be useful for thin clients that are displaying a paginated
 * listing of a large account, which need to know where a particular note
 * sits in the list without retrieving all notes first.
 * 
 * @param authenticationToken
 *   Must be a valid token for the user's account unless the NoteFilter
 *   'notebookGuid' is the GUID of a public notebook.
 * 
 * @param filter
 *   The list of criteria that will constrain the notes to be returned.
 * 
 * @param guid
 *   The GUID of the note to be retrieved.
 * 
 * @return
 *   If the note with the provided GUID is found within the matching note
 *   list, this will return the offset of that note within that list (where
 *   the first offset is 0).  If the note is not found within the set of
 *   notes, this will return -1.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
 *   </li>
 *   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
 *   </li>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) findNoteOffset: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid;

/*
 * Used to find the high-level information about a set of the notes from a
 * user's account based on various criteria specified via a NoteFilter object.
 * <p/>
 * Web applications that wish to periodically check for new content in a user's
 * Evernote account should consider using webhooks instead of polling this API.
 * See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
 * for more information.
 * 
 * @param authenticationToken
 *   Must be a valid token for the user's account unless the NoteFilter
 *   'notebookGuid' is the GUID of a public notebook.
 * 
 * @param filter
 *   The list of criteria that will constrain the notes to be returned.
 * 
 * @param offset
 *   The numeric index of the first note to show within the sorted
 *   results.  The numbering scheme starts with "0".  This can be used for
 *   pagination.
 * 
 * @param maxNotes
 *   The maximum notes to return in this query.  The service will return a set
 *   of notes that is no larger than this number, but may return fewer notes
 *   if needed.  The NoteList.totalNotes field in the return value will
 *   indicate whether there are more values available after the returned set.
 *   Currently, the service will not return more than 250 notes in a single request,
 *   but this number may change in the future.
 * 
 * @param resultSpec
 *   This specifies which information should be returned for each matching
 *   Note. The fields on this structure can be used to eliminate data that
 *   the client doesn't need, which will reduce the time and bandwidth
 *   to receive and process the reply.
 * 
 * @return
 *   The list of notes that match the criteria.
 *   The Notes.sharedNotes field will not be set.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
 *   </li>
 *   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMNotesMetadataList *) findNotesMetadata: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec;

/*
 * Provides clients an extraction of Note.content in plain text to allow clients
 * to render textual snippets in a list. If the notes referenced in the list
 * do not exist or the authentication token does not have access, then
 * the API continues to return a map with those entries omitted. EDAMNotFoundExceptions
 * are not thrown.
 * 
 * @param noteGuids
 *   A list of GUIDs. The Notes must be accessible to the user. The number of noteGuids
 *   provided must not exceed EDAM_USER_NOTE_SNIPPET_MAX
 * 
 * @param maxSnippetLength
 *   Snippets will by truncated so it so that it does not exceed maxSnippetLength
 *   unicode characters excluding an ellipsis if the text is truncated.
 * 
 * @return
 *   a map of note guid's to note snippets. If the GUIDs are not found they are
 *   they are omitted from the keys.
 * 
 * @throws EDAMUserException <ul>
 *   <li> TOO_MANY "noteGuids" - there were more than EDAM_USER_NOTE_SNIPPET_MAX guids
 *        provided"</li>
 *   <li> BAD_DATA_FORMAT "maxSnippetLength" - maxSnippetLength was less than 1</li>
 * </ul>
 * 
 * 
 */
- (NSDictionary<EDAMGuid,NSString *> *) getNoteSnippets: (NSString *) authenticationToken noteGuids: (NSArray<EDAMGuid> *) noteGuids maxSnippetLength: (int32_t) maxSnippetLength;

/*
 * This function is used to determine how many notes are found for each
 * notebook and tag in the user's account, given a current set of filter
 * parameters that determine the current selection.  This function will
 * return a structure that gives the note count for each notebook and tag
 * that has at least one note under the requested filter.  Any notebook or
 * tag that has zero notes in the filtered set will not be listed in the
 * reply to this function (so they can be assumed to be 0).
 * 
 * @param authenticationToken
 *   Must be a valid token for the user's account unless the NoteFilter
 *   'notebookGuid' is the GUID of a public notebook.
 * 
 * @param filter
 *   The note selection filter that is currently being applied.  The note
 *   counts are to be calculated with this filter applied to the total set
 *   of notes in the user's account.
 * 
 * @param withTrash
 *   If true, then the NoteCollectionCounts.trashCount will be calculated
 *   and supplied in the reply. Otherwise, the trash value will be omitted.
 * 
 * @throws EDAMUserException <ul>
 *   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
 *   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
 *   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID</li>
 * </ul>
 */
- (EDAMNoteCollectionCounts *) findNoteCounts: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash;

/*
 * Returns the current state of the note in the service with the provided
 * GUID.  The ENML contents of the note will only be provided if the
 * 'withContent' parameter is true.  The service will include the meta-data
 * for each resource in the note, but the binary contents of the resources
 * and their recognition data will be omitted.
 * If the Note is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).  The applicationData
 * fields are returned as keysOnly.
 * 
 * @param authenticationToken
 *   An authentication token that grants the caller access to the requested note.
 * 
 * @param guid
 *   The GUID of the note to be retrieved.
 * 
 * @param resultSpec
 *   A structure specifying the fields of the note that the caller would like to get.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMNote *) getNoteWithResultSpec: (NSString *) authenticationToken guid: (EDAMGuid) guid resultSpec: (EDAMNoteResultSpec *) resultSpec;

/*
 * DEPRECATED. See getNoteWithResultSpec.
 * 
 * This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
 * mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
 * populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
 */
- (EDAMNote *) getNote: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

/*
 * Get preferences for the current user. Only preferences specified
 * in preferenceNames will be retrieved. An entry per preferenceName
 * will be returned. An empty list will be returned for preferenceName
 * that does not exist or have no associated value in the service.
 * 
 * @param preferenceNames
 *   a list of preferences to be retrieved.
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>DATA_REQUIRED "preferenceNames" - if the list is missing or empty</li>
 * </ul>
 */
- (EDAMPreferences *) getPreferences: (NSString *) authenticationToken preferenceNames: (NSArray<NSString *> *) preferenceNames;

/*
 * Create, update or unset preferences for the current user.
 * 
 * <p>See the documentation of the Preferences structure for a description of how
 * preferences may be used.<p>
 * 
 * @param preferencesToUpdate
 *  A map that contains preference names and their values to be updated or created.
 *  Preference names that are not present in this map will remain unchanged on the
 *  server - you should only include those names for which changes are desired.
 *  A preference will effectively be unset if an empty list is included for a particular
 *  key in this map.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException
 * <ul>
 *  <li>
 *    DATA_REQUIRED "preferencesToUpdate" - if this map is null or empty
 *  </li>
 *  <li>
 *    BAD_DATA_FORMAT "preferencesToUpdate" - if preference names or preference values
 *    are in invalid formats.
 *  </li>
 *  <li>
 *    TOO_MANY "preferencesToUpdate" - if trying to add more preferences than the allowed maximum
 *  </li>
 * </ul>
 */
- (int32_t) updatePreferences: (NSString *) authenticationToken preferencesToUpdate: (NSDictionary<NSString *,NSArray<NSString *> *> *) preferencesToUpdate;

/*
 * Get all of the application data for the note identified by GUID,
 * with values returned within the LazyMap fullMap field.
 * If there are no applicationData entries, then a LazyMap
 * with an empty fullMap will be returned. If your application
 * only needs to fetch its own applicationData entry, use
 * getNoteApplicationDataEntry instead.
 */
- (EDAMLazyMap *) getNoteApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Get the value of a single entry in the applicationData map
 * for the note identified by GUID.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - note not found, by GUID</li>
 *   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
 * </ul>
 */
- (NSString *) getNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

/*
 * Update, or create, an entry in the applicationData map for
 * the note identified by guid.
 */
- (int32_t) setNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

/*
 * Remove an entry identified by 'key' from the applicationData map for
 * the note identified by 'guid'. Silently ignores an unset of a
 * non-existing key.
 */
- (int32_t) unsetNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

/*
 * Returns XHTML contents of the note with the provided GUID.
 * If the Note is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the note to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (NSString *) getNoteContent: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns a block of the extracted plain text contents of the note with the
 * provided GUID.  This text can be indexed for search purposes by a light
 * client that doesn't have capabilities to extract all of the searchable
 * text content from the note and its resources.
 * 
 * If the Note is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the note to be retrieved.
 * 
 * @param noteOnly
 *   If true, this will only return the text extracted from the ENML contents
 *   of the note itself.  If false, this will also include the extracted text
 *   from any text-bearing resources (PDF, recognized images)
 * 
 * @param tokenizeForIndexing
 *   If true, this will break the text into cleanly separated and sanitized
 *   tokens.  If false, this will return the more raw text extraction, with
 *   its original punctuation, capitalization, spacing, etc.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (NSString *) getNoteSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing;

/*
 * Returns a block of the extracted plain text contents of the resource with
 * the provided GUID.  This text can be indexed for search purposes by a light
 * client that doesn't have capability to extract all of the searchable
 * text content from a resource.
 * 
 * If the Resource is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the resource to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (NSString *) getResourceSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns a list of the names of the tags for the note with the provided
 * guid.  This can be used with authentication to get the tags for a
 * user's own note, or can be used without valid authentication to retrieve
 * the names of the tags for a note in a public notebook.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (NSArray<NSString *> *) getNoteTagNames: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Asks the service to make a note with the provided set of information.
 * 
 * @param note
 *   A Note object containing the desired fields to be populated on
 *   the service.
 * 
 * @return
 *   The newly created Note from the service.  The server-side
 *   GUIDs for the Note and any Resources will be saved in this object.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
 *   </li>
 *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
 *   </li>
 *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
 *   </li>
 *   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
 *   </li>
 *   <li> DATA_REQUIRED "Resource.data" - resource data body missing
 *   </li>
 *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
 *   </li>
 *   <li> LIMIT_REACHED "Note" - at max number per account
 *   </li>
 *   <li> LIMIT_REACHED "Note.size" - total note size too large
 *   </li>
 *   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
 *   </li>
 *   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
 *   </li>
 *   <li> LIMIT_REACHED "Resource.data.size" - resource too large
 *   </li>
 *   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
 *   </li>
 *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
 *   </li>
 *   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
 *   </li>
 *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
 *   </li>
 *   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
 *     of the specified tags had an invalid length or pattern
 *   </li>
 *   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
 *     new tags would exceed the maximum number per account
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.notebookGuid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMNote *) createNote: (NSString *) authenticationToken note: (EDAMNote *) note;

/*
 * Submit a set of changes to a note to the service.  The provided data
 * must include the note's guid field for identification. The note's
 * title must also be set.
 * 
 * @param note
 *   A Note object containing the desired fields to be populated on
 *   the service. With the exception of the note's title and guid, fields
 *   that are not being changed do not need to be set. If the content is not
 *   being modified, note.content should be left unset. If the list of
 *   resources is not being modified, note.resources should be left unset.
 * 
 * @return
 *   The metadata (no contents) for the Note on the server after the update.
 *   The Note.sharedNotes field will not be set.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
 *   </li>
 *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
 *   </li>
 *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
 *   </li>
 *   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
 *   </li>
 *   <li> DATA_REQUIRED "Resource.data" - resource data body missing
 *   </li>
 *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
 *   </li>
 *   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
 *   </li>
 *   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
 *   </li>
 *   <li> LIMIT_REACHED "Note.size" - total note size too large
 *   </li>
 *   <li> LIMIT_REACHED "Resource.data.size" - resource too large
 *   </li>
 *   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
 *   </li>
 *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
 *   </li>
 *   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
 *   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
 *     modify the note's tags. note.tags must be unset.
 *   </li>
 *   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
 *     to modify the note's attributes. note.attributes must be unset.
 *   </li>
 *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
 *   </li>
 *   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
 *     of the specified tags had an invalid length or pattern
 *   </li>
 *   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
 *     new tags would exceed the maximum number per account
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - note not found, by GUID
 *   </li>
 *   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
 *   </li>
 * </ul>
 */
- (EDAMNote *) updateNote: (NSString *) authenticationToken note: (EDAMNote *) note;

/*
 * Moves the note into the trash. The note may still be undeleted, unless it
 * is expunged.  This is equivalent to calling updateNote() after setting
 * Note.active = false
 * 
 * @param guid
 *   The GUID of the note to delete.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
 *          update the note.
 *   </li>
 * </ul>
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
 *   </li>
 * </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) deleteNote: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Permanently removes a Note, and all of its Resources,
 * from the service.
 * <p/>
 * NOTE: This function is not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param guid
 *   The GUID of the note to delete.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "Note" - user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) expungeNote: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Permanently removes a list of Notes, and all of their Resources, from
 * the service.  This should be invoked with a small number of Note GUIDs
 * (e.g. 100 or less) on each call.  To expunge a larger number of notes,
 * call this method multiple times.  This should also be used to reduce the
 * number of Notes in a notebook before calling expungeNotebook() or
 * in the trash before calling expungeInactiveNotes(), since these calls may
 * be prohibitively slow if there are more than a few hundred notes.
 * If an exception is thrown for any of the GUIDs, then none of the notes
 * will be deleted.  I.e. this call can be treated as an atomic transaction.
 * <p/>
 * NOTE: This function is not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param noteGuids
 *   The list of GUIDs for the Notes to remove.
 * 
 * @return
 *   The account's updateCount at the end of this operation
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "Note" - user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) expungeNotes: (NSString *) authenticationToken noteGuids: (NSArray<EDAMGuid> *) noteGuids;

/*
 * Permanently removes all of the Notes that are currently marked as
 * inactive.  This is equivalent to "emptying the trash", and these Notes
 * will be gone permanently.
 * <p/>
 * This operation may be relatively slow if the account contains a large
 * number of inactive Notes.
 * <p/>
 * NOTE: This function is not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @return
 *    The number of notes that were expunged.
 */
- (int32_t) expungeInactiveNotes: (NSString *) authenticationToken;

/*
 * Performs a deep copy of the Note with the provided GUID 'noteGuid' into
 * the Notebook with the provided GUID 'toNotebookGuid'.
 * The caller must be the owner of both the Note and the Notebook.
 * This creates a new Note in the destination Notebook with new content and
 * Resources that match all of the content and Resources from the original
 * Note, but with new GUID identifiers.
 * The original Note is not modified by this operation.
 * The copied note is considered as an "upload" for the purpose of upload
 * transfer limit calculation, so its size is added to the upload count for
 * the owner.
 * 
 * If the original note has been shared and has SharedNote records, the shares
 * are NOT copied.
 * 
 * @param noteGuid
 *   The GUID of the Note to copy.
 * 
 * @param toNotebookGuid
 *   The GUID of the Notebook that should receive the new Note.
 * 
 * @return
 *   The metadata for the new Note that was created.  This will include the
 *   new GUID for this Note (and any copied Resources), but will not include
 *   the content body or the binary bodies of any Resources.
 * 
 * @throws EDAMUserException <ul>
 *   <li> LIMIT_REACHED "Note" - at max number per account
 *   </li>
 *   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - user doesn't own
 *   </li>
 *   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMNote *) copyNote: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid;

/*
 * Returns a list of the prior versions of a particular note that are
 * saved within the service.  These prior versions are stored to provide a
 * recovery from unintentional removal of content from a note. The identifiers
 * that are returned by this call can be used with getNoteVersion to retrieve
 * the previous note.
 * The identifiers will be listed from the most recent versions to the oldest.
 * This call is only available for notes in Premium accounts. (I.e. access
 * to past versions of Notes is a Premium-only feature.)
 * 
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
 *   </li>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID.
 *   </li>
 * </ul>
 */
- (NSArray<EDAMNoteVersionId *> *) listNoteVersions: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

/*
 * This can be used to retrieve a previous version of a Note after it has been
 * updated within the service.  The caller must identify the note (via its
 * guid) and the version (via the updateSequenceNumber of that version).
 * to find a listing of the stored version USNs for a note, call
 * listNoteVersions.
 * This call is only available for notes in Premium accounts. (I.e. access
 * to past versions of Notes is a Premium-only feature.)
 * 
 * @param noteGuid
 *   The GUID of the note to be retrieved.
 * 
 * @param updateSequenceNum
 *   The USN of the version of the note that is being retrieved
 * 
 * @param withResourcesData
 *   If true, any Resource elements in this Note will include the binary
 *   contents of their 'data' field's body.
 * 
 * @param withResourcesRecognition
 *   If true, any Resource elements will include the binary contents of the
 *   'recognition' field's body if recognition data is present.
 * 
 * @param withResourcesAlternateData
 *   If true, any Resource elements in this Note will include the binary
 *   contents of their 'alternateData' fields' body, if an alternate form
 *   is present.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
 *   </li>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID.
 *   </li>
 *   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
 *      the corresponding USN.
 *   </li>
 * </ul>
 */
- (EDAMNote *) getNoteVersion: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

/*
 * Returns the current state of the resource in the service with the
 * provided GUID.
 * If the Resource is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).  Only the
 * keys for the applicationData will be returned.
 * 
 * @param guid
 *   The GUID of the resource to be retrieved.
 * 
 * @param withData
 *   If true, the Resource will include the binary contents of the
 *   'data' field's body.
 * 
 * @param withRecognition
 *   If true, the Resource will include the binary contents of the
 *   'recognition' field's body if recognition data is present.
 * 
 * @param withAttributes
 *   If true, the Resource will include the attributes
 * 
 * @param withAlternateData
 *   If true, the Resource will include the binary contents of the
 *   'alternateData' field's body, if an alternate form is present.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMResource *) getResource: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData;

/*
 * Get all of the application data for the Resource identified by GUID,
 * with values returned within the LazyMap fullMap field.
 * If there are no applicationData entries, then a LazyMap
 * with an empty fullMap will be returned. If your application
 * only needs to fetch its own applicationData entry, use
 * getResourceApplicationDataEntry instead.
 */
- (EDAMLazyMap *) getResourceApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Get the value of a single entry in the applicationData map
 * for the Resource identified by GUID.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - Resource not found, by GUID</li>
 *   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
 * </ul>
 */
- (NSString *) getResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

/*
 * Update, or create, an entry in the applicationData map for
 * the Resource identified by guid.
 */
- (int32_t) setResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

/*
 * Remove an entry identified by 'key' from the applicationData map for
 * the Resource identified by 'guid'.
 */
- (int32_t) unsetResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

/*
 * Submit a set of changes to a resource to the service.  This can be used
 * to update the meta-data about the resource, but cannot be used to change
 * the binary contents of the resource (including the length and hash).  These
 * cannot be changed directly without creating a new resource and removing the
 * old one via updateNote.
 * 
 * @param resource
 *   A Resource object containing the desired fields to be populated on
 *   the service.  The service will attempt to update the resource with the
 *   following fields from the client:
 *   <ul>
 *      <li>guid:  must be provided to identify the resource
 *      </li>
 *      <li>mime
 *      </li>
 *      <li>width
 *      </li>
 *      <li>height
 *      </li>
 *      <li>duration
 *      </li>
 *      <li>attributes:  optional.  if present, the set of attributes will
 *           be replaced.
 *      </li>
 *   </ul>
 * 
 * @return
 *   The Update Sequence Number of the resource after the changes have been
 *   applied.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
 *   </li>
 *   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
 *   </li>
 *   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) updateResource: (NSString *) authenticationToken resource: (EDAMResource *) resource;

/*
 * Returns binary data of the resource with the provided GUID.  For
 * example, if this were an image resource, this would contain the
 * raw bits of the image.
 * If the Resource is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the resource to be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (NSData *) getResourceData: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns the current state of a resource, referenced by containing
 * note GUID and resource content hash.
 * 
 * @param noteGuid
 *   The GUID of the note that holds the resource to be retrieved.
 * 
 * @param contentHash
 *   The MD5 checksum of the resource within that note. Note that
 *   this is the binary checksum, for example from Resource.data.bodyHash,
 *   and not the hex-encoded checksum that is used within an en-media
 *   tag in a note body.
 * 
 * @param withData
 *   If true, the Resource will include the binary contents of the
 *   'data' field's body.
 * 
 * @param withRecognition
 *   If true, the Resource will include the binary contents of the
 *   'recognition' field's body.
 * 
 * @param withAlternateData
 *   If true, the Resource will include the binary contents of the
 *   'alternateData' field's body, if an alternate form is present.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
 *   </li>
 *   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note" - not found, by guid
 *   </li>
 *   <li> "Resource" - not found, by hash
 *   </li>
 * </ul>
 */
- (EDAMResource *) getResourceByHash: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData;

/*
 * Returns the binary contents of the recognition index for the resource
 * with the provided GUID.  If the caller asks about a resource that has
 * no recognition data, this will throw EDAMNotFoundException.
 * If the Resource is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the resource whose recognition data should be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 *   <li> "Resource.recognition" - resource has no recognition
 *   </li>
 * </ul>
 */
- (NSData *) getResourceRecognition: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * If the Resource with the provided GUID has an alternate data representation
 * (indicated via the Resource.alternateData field), then this request can
 * be used to retrieve the binary contents of that alternate data file.
 * If the caller asks about a resource that has no alternate data form, this
 * will throw EDAMNotFoundException.
 * 
 * @param guid
 *    The GUID of the resource whose recognition data should be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 *   <li> "Resource.alternateData" - resource has no recognition
 *   </li>
 * </ul>
 */
- (NSData *) getResourceAlternateData: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Returns the set of attributes for the Resource with the provided GUID.
 * If the Resource is found in a public notebook, the authenticationToken
 * will be ignored (so it could be an empty string).
 * 
 * @param guid
 *   The GUID of the resource whose attributes should be retrieved.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
 *   </li>
 *   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Resource.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (EDAMResourceAttributes *) getResourceAttributes: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Clients should make this call once per day to receive a bundle of ads that
 * will be displayed for the subsequent 24 hour period.
 * <p/>
 * NOTE: This function is not available to third party applications.
 * 
 * @param adParameters
 *   A set of parameters that help the service determine which ads to return.
 */
- (NSArray<EDAMAd *> *) getAds: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

/*
 * A thin client should make this call to retrieve a single random ad for
 * immediate display.
 * <p/>
 * NOTE: This function is not available to third party applications.
 * 
 * @param adParameters
 *   A set of parameters to help the service determine which ad to return.
 *   The 'impression' field should either be absent (if no ads have been
 *   displayed previously), or else it should contain the identifier for
 *   the most recently-displayed ad so that the service can give a different
 *   ad.
 */
- (EDAMAd *) getRandomAd: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

/*
 * <p>
 * Looks for a user account with the provided userId on this NoteStore
 * shard and determines whether that account contains a public notebook
 * with the given URI.  If the account is not found, or no public notebook
 * exists with this URI, this will throw an EDAMNotFoundException,
 * otherwise this will return the information for that Notebook.
 * </p>
 * <p>
 * If a notebook is visible on the web with a full URL like
 * http://www.evernote.com/pub/sethdemo/api
 * Then 'sethdemo' is the username that can be used to look up the userId,
 * and 'api' is the publicUri.
 * </p>
 * 
 * @param userId
 *    The numeric identifier for the user who owns the public notebook.
 *    To find this value based on a username string, you can invoke
 *    UserStore.getPublicUserInfo
 * 
 * @param publicUri
 *    The uri string for the public notebook, from Notebook.publishing.uri.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Publishing.uri" - not found, by URI</li>
 * </ul>
 * 
 * @throws EDAMSystemException <ul>
 *   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
 *     taken down (for all requesters).</li>
 *   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
 *     down for the requester because of an IP-based country lookup.</li>
 * </ul>
 */
- (EDAMNotebook *) getPublicNotebook: (EDAMUserID) userId publicUri: (NSString *) publicUri;

/*
 * @Deprecated See createOrUpdateNotebookShares.
 */
- (EDAMSharedNotebook *) createSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

/*
 * * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
 * *
 * * Share a notebook with an email address, and optionally to a specific
 * * recipient. If an existing SharedNotebook associated with
 * * sharedNotebook.notebookGuid is found by recipientUsername or email, then
 * * the values of sharedNotebook will be used to update the existing record,
 * * else a new record will be created.
 * *
 * * If recipientUsername is set and there is already a SharedNotebook
 * * for that Notebook with that recipientUsername and the privileges on the
 * * existing notebook are lower, than on this one, this will update the
 * * privileges and sharerUserId. If there isn't an existing SharedNotebook for
 * * recipientUsername, this will create and return a shared notebook for that
 * * email and recipientUsername. If recipientUsername is not set and there
 * * already is a SharedNotebook for a Notebook for that email address and the
 * * privileges on the existing SharedNotebook are lower than on this one, this
 * * will update the privileges and sharerUserId, and return the updated
 * * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
 * * the email address.
 * *
 * * If the authenticationToken is a Business auth token, recipientUsername is
 * * set and the recipient is in the same business as the business auth token,
 * * this method will also auto-join the business user to the SharedNotebook -
 * * that is it will set serviceJoined on the SharedNotebook and create a
 * * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
 * * The LinkedNotebook creation happens out-of-band, so there will be a delay
 * * on the order of half a minute between the SharedNotebook and LinkedNotebook
 * * creation.
 * *
 * * Also handles sending an email to the email addresses: if a SharedNotebook
 * * is being created, this will send the shared notebook invite email, and
 * * if a SharedNotebook already exists, it will send the shared notebook
 * * reminder email. Both these emails contain a link to join the notebook.
 * * If the notebook is being auto-joined, it sends an email with that
 * * information to the recipient.
 * *
 * * @param authenticationToken
 * *   Must be an authentication token from the owner or a shared notebook
 * *   authentication token or business authentication token with sufficient
 * *   permissions to change invitations for a notebook.
 * *
 * * @param sharedNotebook
 * *   A shared notebook object populated with the email address of the share
 * *   recipient, the notebook guid and the access permissions. All other
 * *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
 * *   field must be explicitly set with either a true or false value.
 * *
 * * @param message
 * *   The sharer-defined message to put in the email sent out.
 * *
 * * @return
 * *   The fully populated SharedNotebook object including the server assigned
 * *   globalId which can both be used to uniquely identify the SharedNotebook.
 * *
 * * @throws EDAMUserException <ul>
 * *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
 * *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
 * *       SharedNotebook.privilegeLevel was not set.</li>
 * *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
 * *       set. requireLogin is deprecated.</li>
 * *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
 * *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
 * *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
 *         owner's account is not confirmed.</li>
 * *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
 * *       recipientSettings is set in the sharedNotebook.  Only the recipient
 * *       can set these values via the setSharedNotebookRecipientSettings
 * *       method.</li>
 * *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
 * *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
 * *   </ul>
 * * @throws EDAMNotFoundException <ul>
 * *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
 * *   </li>
 * *   </ul>
 */
- (EDAMSharedNotebook *) shareNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook message: (NSString *) message;

/*
 * Share a notebook by a messaging thread ID or a list of contacts. This function is
 * intended to be used in conjunction with Evernote messaging, and as such does not
 * notify the recipient that a notebook has been shared with them.
 * 
 * Sharing with a subset of participants on a thread is accomplished by specifying both
 * a thread ID and a list of contacts. This ensures that even if those contacts are
 * on the thread under a deactivated identity, the correct user (the one who has the
 * given contact on the thread) receives the share.
 * 
 * @param authenticationToken
 *   An authentication token that grants the caller permission to share the notebook.
 *   This should be an owner token if the notebook is owned by the caller.
 *   If the notebook is a business notebook to which the caller has full access,
 *   this should be their business authentication token. If the notebook is a shared
 *   (non-business) notebook to which the caller has full access, this should be the
 *   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
 * 
 * @param shareTemplate
 *   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
 *   should be shared, and the recipient information.
 * 
 * @return
 *   A structure containing the USN of the Notebook after the change and a list of created
 *   or updated SharedNotebooks.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
 *   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
 *     valid GUID</li>
 *   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
 *   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
 *     specified</li>
 *   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
 *     is not allowed.</li>
 *   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
 *     specified, either by thread ID or as a list of contacts</li>
 *   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
 *     number of shares</li>
 * </ul>
 * 
 * @throws EDAMInvalidContactsException <ul>
 *   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
 *     in shareTemplate.recipients was not syntactically valid, or if attempting to
 *     share a notebook with an Evernote identity that the sharer does not have a
 *     connection to. The exception will specify which recipients were invalid.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
 *   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
 *     specified, but no thread with that ID exists</li>
 * </ul>
 */
- (EDAMCreateOrUpdateNotebookSharesResult *) createOrUpdateNotebookShares: (NSString *) authenticationToken shareTemplate: (EDAMNotebookShareTemplate *) shareTemplate;

/*
 * @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
 */
- (int32_t) updateSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

/*
 * @deprecated Use setNotebookRecipientSettings instead. This API will be removed in the future.
 */
- (int32_t) setSharedNotebookRecipientSettings: (NSString *) authenticationToken sharedNotebookId: (int64_t) sharedNotebookId recipientSettings: (EDAMSharedNotebookRecipientSettings *) recipientSettings;

/*
 * Set values for the recipient settings associated with a notebook share. Only the
 * recipient of the share can update their recipient settings.
 * 
 * If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
 * you must leave that field unset in recipientSettings.
 * This method will skip that field for updates and attempt to leave the existing value as
 * it is.
 * 
 * If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
 * will be either left as null or converted to false (if currently true).
 * 
 * @param authenticationToken The owner authentication token for the recipient of the share.
 * 
 * @return The updated Notebook with the new recipient settings. Note that some of the
 * recipient settings may differ from what was requested. Clients should update their state
 * based on this return value.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
 *       notebookGuid on the given shard.</li>
 *   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
 *       user and is also not published to their business.</li>
 * </ul>
 * 
 * @throws EDAMUserException <ul>
 *   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
 *       allowed to set recipient settings on the specified notebook.</li>
 *   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
 *       is allowed only for notebooks which belong to the same business as the user.</li>
 *   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
 *       to false and any of reminder* settings to true.</li>
 * </ul>
 */
- (EDAMNotebook *) setNotebookRecipientSettings: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid recipientSettings: (EDAMNotebookRecipientSettings *) recipientSettings;

/*
 * Send a reminder email to some or all of the email addresses that a notebook has been
 * shared with via the pre-Work Chat sharing flows. The email includes the current link
 * to view the notebook. Recipients invited via Work Chat will not receive an email.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param authenticationToken
 *   The auth token of the user with permissions to share the notebook
 * 
 * @param notebookGuid
 *   The guid of the shared notebook
 * 
 * @param messageText
 *  User provided text to include in the email
 * 
 * @param recipients
 *  The email addresses of the recipients. If this list is empty then all of the
 *  users that the notebook has been shared with are emailed.
 *  If an email address doesn't correspond to an existing invitation or membership
 *  for the notebook then that address is ignored.
 * 
 * @return
 *  The number of messages sent
 * 
 * @throws EDAMUserException <ul>
 *   <li> LIMIT_REACHED "(recipients)" -
 *     The email can't be sent because this would exceed the user's daily
 *     email limit.
 *   </li>
 *   <li> PERMISSION_DENIED "Notebook.guid" - The user doesn't have permission to
 *     send a message for the specified notebook.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) sendMessageToSharedNotebookMembers: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSArray<NSString *> *) recipients;

/*
 * Lists the collection of shared notebooks for all notebooks in the
 * users account.
 * 
 * @return
 *  The list of all SharedNotebooks for the user
 */
- (NSArray<EDAMSharedNotebook *> *) listSharedNotebooks: (NSString *) authenticationToken;

/*
 * Expunges the SharedNotebooks in the user's account using the
 * SharedNotebook.id as the identifier.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param
 *   sharedNotebookIds - a list of ShardNotebook.id longs identifying the
 *       objects to delete permanently.
 * 
 * @return
 *   The account's update sequence number.
 */
- (int32_t) expungeSharedNotebooks: (NSString *) authenticationToken sharedNotebookIds: (NSArray<NSNumber *> *) sharedNotebookIds;

/*
 * Asks the service to make a linked notebook with the provided name, username
 * of the owner and identifiers provided. A linked notebook can be either a
 * link to a public notebook or to a private shared notebook.
 * 
 * @param linkedNotebook
 *   The desired fields for the linked notebook must be provided on this
 *   object.  The name of the linked notebook must be set. Either a username
 *   uri or a shard id and share key must be provided otherwise a
 *   EDAMUserException is thrown.
 * 
 * @return
 *   The newly created LinkedNotebook.  The server-side id will be
 *   saved in this object's 'id' field.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
 *   </li>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
 *     if public notebook set but bad uri
 *   </li>
 *   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
 *     if private notebook but shard id not provided
 *   </li>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
 *   </li>
 * </ul>
 * 
 * @throws EDAMSystemException <ul>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
 *     if a bad global identifer was set on a private notebook
 *   </li>
 * </ul>
 */
- (EDAMLinkedNotebook *) createLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

/*
 * @param linkedNotebook
 *   Updates the name of a linked notebook.
 * 
 * @return
 *   The Update Sequence Number for this change within the account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
 *   </li>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
 *   </li>
 *   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
 *   </li>
 * </ul>
 */
- (int32_t) updateLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

/*
 * Returns a list of linked notebooks
 */
- (NSArray<EDAMLinkedNotebook *> *) listLinkedNotebooks: (NSString *) authenticationToken;

/*
 * Permanently expunges the linked notebook from the account.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param guid
 *   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
 *   from the account.
 */
- (int32_t) expungeLinkedNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Asks the service to produce an authentication token that can be used to
 * access the contents of a shared notebook from someone else's account.
 * This authenticationToken can be used with the various other NoteStore
 * calls to find and retrieve notes, and if the permissions in the shared
 * notebook are sufficient, to make changes to the contents of the notebook.
 * 
 * @param shareKeyOrGlobalId
 *   May be one of the following:
 *   <ul>
 *     <li>A share key for a shared notebook that was granted to some recipient
 *         Must be used if you are joining a notebook unless it was shared via
 *         createOrUpdateNotebookShares. Share keys are delivered out-of-band
 *         and are generally not available to clients. For security reasons,
 *         share keys may be invalidated at the discretion of the service.
 *     </li>
 *     <li>The shared notebook global identifier. May be used to access a
 *         notebook that is already joined.
 *     </li>
 *     <li>The Notebook GUID. May be used to access a notebook that was already
 *         joined, or to access a notebook that was shared with the recipient
 *         via createOrUpdateNotebookShares.
 *     </li>
 *   </ul>
 * 
 * @param authenticationToken
 *   If a non-empty string is provided, this is the full user-based
 *   authentication token that identifies the user who is currently logged in
 *   and trying to access the shared notebook.
 *   If this string is empty, the service will attempt to authenticate to the
 *   shared notebook without any logged in user.
 * 
 * @throws EDAMSystemException <ul>
 *   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
 *   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
 * </ul>
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
 *          no valid authentication token was provided.
 *   </li>
 *   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
 *          and another username has already been bound to this notebook.
 *   </li>
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateToSharedNotebook: (NSString *) shareKeyOrGlobalId authenticationToken: (NSString *) authenticationToken;

/*
 * This function is used to retrieve extended information about a shared
 * notebook by a guest who has already authenticated to access that notebook.
 * This requires an 'authenticationToken' parameter which should be the
 * resut of a call to authenticateToSharedNotebook(...).
 * I.e. this is the token that gives access to the particular shared notebook
 * in someone else's account -- it's not the authenticationToken for the
 * owner of the notebook itself.
 * 
 * @param authenticationToken
 *   Should be the authentication token retrieved from the reply of
 *   authenticateToSharedNotebook(), proving access to a particular shared
 *   notebook.
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "authenticationToken" -
 *          authentication token doesn't correspond to a valid shared notebook
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "SharedNotebook.id" - the shared notebook no longer exists
 *   </li>
 * </ul>
 */
- (EDAMSharedNotebook *) getSharedNotebookByAuth: (NSString *) authenticationToken;

/*
 * Attempts to send a single note to one or more email recipients.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 * 
 * @param authenticationToken
 *    The note will be sent as the user logged in via this token, using that
 *    user's registered email address.  If the authenticated user doesn't
 *    have permission to read that note, the emailing will fail.
 * 
 * @param parameters
 *    The note must be specified either by GUID (in which case it will be
 *    sent using the existing data in the service), or else the full Note
 *    must be passed to this call.  This also specifies the additional
 *    email fields that will be used in the email.
 * 
 * @throws EDAMUserException <ul>
 *   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
 *     The email can't be sent because this would exceed the user's daily
 *     email limit.
 *   </li>
 *   <li> BAD_DATA_FORMAT "(email address)" -
 *     email address malformed
 *   </li>
 *   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
 *     if there are no To: or Cc: addresses provided.
 *   </li>
 *   <li> DATA_REQUIRED "Note.title" -
 *     if the caller provides a Note parameter with no title
 *   </li>
 *   <li> DATA_REQUIRED "Note.content" -
 *     if the caller provides a Note parameter with no content
 *   </li>
 *   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
 *   </li>
 *   <li> DATA_REQUIRED "NoteEmailParameters.note" -
 *     if no guid or note provided
 *   </li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (void) emailNote: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters;

/*
 * If this note is not already shared publicly (via its own direct URL), then this
 * will start sharing that note.
 * This will return the secret "Note Key" for this note that
 * can currently be used in conjunction with the Note's GUID to gain direct
 * read-only access to the Note.
 * If the note is already shared, then this won't make any changes to the
 * note, and the existing "Note Key" will be returned.  The only way to change
 * the Note Key for an existing note is to stopSharingNote first, and then
 * call this function.
 * 
 * @param guid
 *   The GUID of the note to be shared.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - not found, by GUID</li>
 * </ul>
 */
- (NSString *) shareNote: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * If this note is shared publicly then this will stop sharing that note
 * and invalidate its "Note Key", so any existing URLs to access that Note
 * will stop working.
 * 
 * If the Note is not shared, then this function will do nothing.
 * 
 * This function does not remove invididual shares for the note. To remove
 * individual shares, see stopSharingNoteWithRecipients.
 * 
 * @param guid
 *   The GUID of the note to be un-shared.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
 *   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Note.guid" - not found, by GUID</li>
 * </ul>
 */
- (void) stopSharingNote: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Expunges all existing SharedNotes for a given note, with the exception of
 * shares that grant the caller permission to call this function. This function
 * does not affect the public share status of the note. To stop sharing the
 * note publicly, see stopSharingNote.
 * 
 * This is intended to be a temporary function for use until clients have
 * time to build full note sharing management UIs.
 * 
 * @param authenticationToken
 *   An authentication token that grants the caller access to manage sharing
 *   for the specified note. See createOrUpdateSharedNotes for a description
 *   of the types of tokens that may be used.
 * 
 * @param guid
 *   The GUID of the note.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "Note.guid" - if no note GUID is provided</li>
 *   <li>BAD_DATA_FORMAT "Note.guid" - if the note GUID is invalid</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Note.guid" - not found, by GUID</li>
 * </ul>
 */
- (void) stopSharingNoteWithRecipients: (NSString *) authenticationToken guid: (EDAMGuid) guid;

/*
 * Asks the service to produce an authentication token that can be used to
 * access the contents of a single Note which was individually shared
 * from someone's account.
 * This authenticationToken can be used with the various other NoteStore
 * calls to find and retrieve the Note and its directly-referenced children.
 * 
 * @param guid
 *   The GUID identifying this Note on this shard.
 * 
 * @param noteKey
 *   The 'noteKey' identifier from the Note that was originally created via
 *   a call to shareNote() and then given to a recipient to access.
 * 
 * @param authenticationToken
 *   An optional authenticationToken that identifies the user accessing the
 *   shared note. This parameter may be required to access some shared notes.
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
 *     shared, or the noteKey doesn't match the current key for this note
 *   </li>
 *   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
 *     required to access this Note, but either no authentication token or a
 *     "non-owner" authentication token was provided.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "guid" - the note with that GUID is not found
 *   </li>
 * </ul>
 * 
 * @throws EDAMSystemException <ul>
 *   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
 *     all requesters).
 *   </li>
 *   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
 *     for the requester because of an IP-based country lookup.
 *   </ul>
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateToSharedNote: (NSString *) guid noteKey: (NSString *) noteKey authenticationToken: (NSString *) authenticationToken;

/*
 * Share a note by a messaging thread ID or a list of contacts. This function is
 * intended to be used in conjunction with Evernote messaging, and as such does not
 * notify the recipient that a note has been shared with them.
 * 
 * If a SharedNote already exists for the note identified by shareTemplate.noteGuid and the
 * given recipient, the existing record will be updated as long as the privilege specified
 * in shareTemplate.privilege is higher than the one currently possessed by the recipient.
 * This function will not remove or downgrade a recipient's privileges.
 * 
 * Sharing with a subset of participants on a thread is accomplished by specifying both
 * a thread ID and a list of contacts. This ensures that even if those contacts are
 * on the thread under a deactivated identity, the correct user (the one who has the
 * given contact on the thread) receives the share.
 * 
 * @param authenticationToken
 *   An authentication token that grants the caller permission to share the note.
 *   This should be an owner token if the note is owned by the caller or
 *   shared with the caller via note sharing. If the note is in a business
 *   notebook to which the caller has full access, this should be their business
 *   authentication token. If the note is in a shared (non-business) notebook
 *   to which the caller has full access, this should be the shared notebook
 *   authentication token returned by NoteStore.authenticateToNotebook.
 * 
 * @param shareTemplate
 *   Specifies the GUID of the note to be shared, the privilege at which the note should be
 *   shared, and the contact information for the recipient(s).
 * 
 * @return
 *   The new or updated SharedNote records, one per recipient.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "Note.guid" - if no note GUID was specified</li>
 *   <li>BAD_DATA_FORMAT "Note.guid" - if shareTemplate.noteGuid is not a valid GUID</li>
 *   <li>DATA_REQUIRED "shareTemplate" - if no shareTemplate was specified</li>
 *   <li>DATA_REQUIRED "SharedNoteTemplate.privilege" - if no privilege was specified</li>
 *   <li>DATA_REQUIRED "SharedNoteTemplate.recipients" - if no recipients were specified,
 *     either by thread ID or as a list of contacts</li>
 *   <li>DATA_REQUIRED "contact.type" - if a recipient was missing a type</li>
 *   <li>DATA_REQUIRED "contact.id" - if a recipient was missing an ID</li>
 *   <li>LIMIT_REACHED "SharedNote" - if the note has reached its maximum number of shares</li>
 * </ul>
 * 
 * @throws EDAMInvalidContactsException <ul>
 *   <li>"SharedNoteTemplate.recipients" - if one or more of the recipients specified in
 *     shareTemplate.recipients was not syntactically valid, or if attempting to share a note
 *     with an Evernote identity that the sharer does not have a connection to. The exception
 *     will specify which recipients were invalid.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Note.guid" - if no note with the specified GUID was found</li>
 *   <li>"SharedNoteTemplate.recipientThreadId" - if the recipient thread ID was specified, but
 *     no thread with that ID exists</li>
 * </ul>
 */
- (NSArray<EDAMSharedNote *> *) createOrUpdateSharedNotes: (NSString *) authenticationToken shareTemplate: (EDAMSharedNoteTemplate *) shareTemplate;

/*
 * Identify related entities on the service, such as notes,
 * notebooks, tags and users in a business related to notes or content.
 * 
 * @param query
 *   The information about which we are finding related entities.
 * 
 * @param resultSpec
 *   Allows the client to indicate the type and quantity of
 *   information to be returned, allowing a saving of time and
 *   bandwidth.
 * 
 * @return
 *   The result of the query, with information considered
 *   to likely be relevantly related to the information
 *   described by the query.
 * 
 * @throws EDAMUserException <ul>
 *   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
 *     a zero-length plain text value.
 *   </li>
 *   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
 *     invalid Note GUID, that is, one that does not match the constraints
 *     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
 *   </li>
 *   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
 *     the note identified by RelatedQuery.noteGuid.
 *   </li>
 *   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
 *     findExperts in the context of a non business user (i.e. The authenticationToken
 *     is not a business auth token).
 *   </li>
 *   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
 *     in the result spec.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
 *     found, if that field has been set in the query.
 *   </li>
 * </ul>
 */
- (EDAMRelatedResult *) findRelated: (NSString *) authenticationToken query: (EDAMRelatedQuery *) query resultSpec: (EDAMRelatedResultSpec *) resultSpec;

/*
 * Find the relevant search suggestions from within the note content / titles and tags
 * that match the specified suggestion query.
 * 
 * @param query
 *   The information for which we are finding search suggestions
 * 
 * @param resultSpec
 *   Allows the client to indicate the number of suggestions desired
 * 
 * @return
 *   The relevant search suggestions found for the specified query
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "SearchSuggestionQuery.prefix" - If you did not provide the query prefix </li>
 *   <li> BAD_DATA_FORMAT "SearchSuggestionQuery.prefix" - If you provided a a prefix with insufficient length
 *      (enforced by EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MIN, EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MAX)
 *   </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - If the notebook guid is malformed
 * (as enforced by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX) . </li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - If any of the tag guids are malformed
 * (as enforced by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX) .</li>
 *   <li> BAD_DATA_FORMAT "NoteFilter.words" - If the restrictive search string is invalid
 * (as enforced by EDAM_SEARCH_QUERY_LEN_MIN, EDAM_SEARCH_QUERY_LEN_MAX and EDAM_SEARCH_QUERY_REGEX) .  </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"NoteFilter.notebookGuid" - the notebook with the specified GUID is not
 *     found (if the field has been set in the NoteFilter).
 *   </li>
 * </ul>
 */
- (EDAMSearchSuggestionResult *) findSearchSuggestions: (NSString *) authenticationToken query: (EDAMSearchSuggestionQuery *) query resultSpec: (EDAMSearchSuggestionResultSpec *) resultSpec;

/*
 * 
 * Set a value for a given user setting.  Most values associated with a User are
 * read-only via the service API, but some can be changed with various restrictions.
 * For user settings that can change via the service API, this is the method to use.
 * 
 * <dl>
 * <dt>RECEIVE_REMINDER_EMAIL</dt>
 * <dd>Set whether or not the user should receive reminder e-mail.  Valid values
 *     are the string forms of the ReminderEmailConfig enumeration.  Example valid
 *     values include "DO_NOT_SEND" and "SEND_DAILY_EMAIL".
 * </dd>
 * <dt>TIMEZONE</dt>
 * <dd>Set the time zone identifier for the user, to be used by the service for features
 *     such as sending reminder e-mail.  The value must be a valid time zone identifier
 *     as returned by findTimeZones.  You may only set the time zone if it is currently
 *     unset.  Changing an existing time zone is not possible with this routine.
 * </dd>
 * </dl>
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "name"
 *   <li>DATA_REQUIRED "value"
 *   <li>BAD_DATA_FORMAT "value"
 *   <li>DATA_CONFLICT "timezone already set"
 * 
 */
- (void) updateUserSetting: (NSString *) authenticationToken setting: (int) setting value: (NSString *) value;

/*
 * Search the Service time zone database for time zones that correspond to a client's
 * time zone, useful to set the correct time zone identifier on the service for features
 * such as reminder e-mail summaries.  Different operating systems use different time
 * zone databases. The count of returned TimeZones can be restricted by maxTimeZones,
 * where maxTimeZones must be >= 1 such that at least one TimeZone can be returned, if available.
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>DATA_REQUIRED "timeZoneSpec" -
 *      <ul>
 *         <li>if timeZoneSpec was null.</il>
 *         <li>if timeZoneSpec.id was not set or both timeZoneSpec.idrawUTCOffsetMillis and
 *         timeZoneSpec.dstSavingsAdjustmentMillis were not set.</il>
 *      </ul>
 *   <li>DATA_CONFLICT "maxTimeZones" - if maxTimeZones was &lt; 1.</li>
 *   <li>PERMISSION_DENIED "authenticationToken" - the user/client of this auth token does not
 *     have the priviledge to find time zones.</li>
 * </ul>
 */
- (NSArray<EDAMTimeZone *> *) findTimeZones: (NSString *) authenticationToken timeZoneSpec: (EDAMTimeZoneSpec *) timeZoneSpec maxTimeZones: (int32_t) maxTimeZones;

/*
 * Search the user's contacts data and return a list of contacts that match the criteria
 * specified in the query. This is useful for auto-completing on the client side.
 * 
 * Contacts data are from the following sources:
 * <ul>
 *   <li>recently emailed addresses (User.attributes.recentMailedaddresses)</li>
 *   <li>current shared notebook contacts (SharedNotebook.email)</li>
 *   <li>contacts in the business (BusinessUserInfo.email or User.email)</li>
 *   <li>Google contacts (if the user is connected to Google)</li>
 * </ul>
 * 
 * All requests must be made against user's home shard using owner authentication token.
 * 
 * The server does its best to de-duplicate contacts based on their email addresses. Clients
 * can expect email addresses to be unique in the result. Clients are responsible for merging the
 * result with local address book or other data source if available.
 * 
 * Clients should consider caching result from the server and further refine the search to
 * avoid repeated queries where possible. For example, clients can cache results for the query
 * "e" and when user types another letter such as "v" then cached data can be used instead of
 * sending a new query of "ev".
 * 
 * @param query
 *   Information we are trying to find out from user's contacts data.
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>PERMISSION_DENIED "authenticationToken" - the user/client of this auth token does not
 *     have the priviledge to search contacts data.</li>
 *   <li>DATA_REQUIRED "query.prefix" - missing required prefix string.</li>
 * </ul>
 */
- (NSArray<EDAMContact *> *) findContacts: (NSString *) authenticationToken query: (EDAMContactsQuery *) query;

/*
 * Search for content with an Evernote Business account based on a BusinessQuery.
 * This search performs three different logical operations:
 * 
 * <ul>
 *   <li>Finds the count of notebooks whose names or descriptions matched the literal terms within the query</li>
 *   <li>Finds the count of notes per notebook that matched the query</li>
 *   <li>Finds a list of experts based on the literal terms within the query</li>
 * </ul>
 * 
 * The search is made against all business notesbooks that the user can read. All requests must be made
 * against the business shard using a user's business authentication token.
 * 
 * @param query
 *   Information we are trying to find in the business
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>DATA_REQUIRED "query.filter" - missing required note filter.</li>
 *   <li>DATA_CONFLICT "query.filter.notebookGuid" - notebook guid must not be specified.</li>
 *   <li>DATA_CONFLICT "query.filter.words" - search grammar must not contain "notebook:" identifier.</li>
 * </ul>
 */
- (EDAMBusinessQueryResult *) findInBusiness: (NSString *) authenticationToken query: (EDAMBusinessQuery *) query;

/*
 * Makes a business note visible to anybody in a business who has
 * the note's guid. Must be called on the business shard by a user
 * who is an active member of the business and has full access to
 * the notebook containing the note.
 * 
 * @param noteGuid
 *            the guid of the note to share to the business. Must correspond to a business note.
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>PERMISSION_DENIED "authenticationToken" - the user/client of this auth token does not
 *     have permission to share this note with the business.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - note not found, by GUID
 *   </li>
 * </ul>
 * 
 * @return usn  the USN of the note after the change
 */
- (int32_t) shareNoteWithBusiness: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

/*
 * If the given note was already shared to a business using
 * shareNoteToBusiness, stop sharing the note. If the note was
 * not already shared to a business, do nothing.
 * 
 * @param noteGuid
 *            the guid of the note to stop sharing with the business. Must be a business note.
 * 
 * @throws EDAMUserException
 * <ul>
 *   <li>PERMISSION_DENIED "authenticationToken" - the user/client of this auth token does not
 *     have permission to stop sharing this note with the business.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Note.guid" - note not found, by GUID
 *   </li>
 * </ul>
 * @return usn  the USN of the note after the change
 */
- (int32_t) stopSharingNoteWithBusiness: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

/*
 * Sends the owner of the notebook an email from the user asking for access to the
 * notebook at the privilege level specified. For a business notebook, if the contact of
 * the notebook is still a member of the business and has reshare privileges, this email
 * will be sent to them, else it will be sent to a business admin. This method must be
 * called from the notebook owner's shard. A privilegeLevel of GROUP cannot be
 * requested.
 * 
 * @param authenticationToken  an owner token representing the user requesting access
 * @param notebookGuid  the guid of the notebook
 * @param privilegeLevel  the SharedNotebookPrivilegeLevel to request
 * 
 * @throws EDAMUserException <ul>
 *   <li> EDAMErrorCode.DATA_REQUIRED "privilegeLevel" - privilegeLevel was null </li>
 *   <li> EDAMErrorCode.LIMIT_REACHED "email" - the user has hit their daily email limit
 *     </li>
 *   <li> EDAMErrorCode.LIMIT_REACHED "notebookAccessRequest" - the user has hit the
 *     limit for the number of times they can request access to this notebook </li>
 *   <li> EDAMErrorCode.BAD_DATA_FORMAT "privilegeLevel" - privilegeLevel was set to
 *     GROUP </li>
 *   <li> EDAMErrorCode.DATA_CONFLICT "userId" - the user is the notebook owner </li>
 *   <li> EDAMErrorCode.DATA_CONFLICT "privilegeLevel" - trying to request
 *     BUSINESS_FULL_ACCESS for a personal share.</li>
 * </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - Notebook not found</li>
 * </ul>
 */
- (void) requestAccessToNotebook: (NSString *) authToken notebookGuid: (NSString *) notebookGuid privilegeLevel: (int) privilegeLevel;

/*
 * A client makes this call to determine the current locking/collaboration status of
 * a note. This returns information about who has recently viewed that note, and who
 * may currently have a cooperative lock on that note.
 * This call itself causes the caller to be considered to be a "viewer" of that note.
 * So the ID of the authenticated user who is making this call will be within the list
 * of 'viewingUserIds', along with any prior viewers.
 * <br/>
 * This call should only be performed on notes that are contained within shared
 * notebooks or business notebooks. I.e. there's no reason to ask the service for
 * the locking/viewing status of a note which is clearly only accessible by the
 * (single) owner of that note.
 * 
 * @param noteGuid  the identifier of the note that is being viewed by the client. The
 *    caller must have permission to view that note (e.g. via getNote)
 * 
 * @throws EDAMUserException <ul>
 *   <li> EDAMErrorCode.PERMISSION_DENIED "Note" - if the caller doesn't have permission
 *     to read the indicated note.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *    <li> "Note.guid" - note not found</li>
 * </ul>
 */
- (EDAMNoteLockStatus *) getNoteLockStatus: (NSString *) authenticationToken noteGuid: (NSString *) noteGuid;

/*
 * This call will acquire the cooperative note editing lock for a note for the caller,
 * if that caller is permitted to do so.
 * This will return the same NoteLockStatus as getLockNoteStatus, but the caller will
 * see their userId holds the lock in that structure when this is successful.
 * <br/>
 * This call should only be performed on notes that are contained within shared
 * notebooks or business notebooks. I.e. there's no reason to ask the service for
 * the locking/viewing status of a note which is clearly only accessible by the
 * (single) owner of that note.
 * <br/>
 * If the service can't acquire the lock for the caller, this will throw an exception.
 * 
 * @param noteGuid  the identifier of the note that is being locked by the client. The
 *    caller must have permission to modify that note (e.g. via updateNote)
 * 
 * @throws EDAMUserException <ul>
 *   <li> EDAMErrorCode.PERMISSION_DENIED "Note" - if the caller doesn't have permission
 *     to read the indicated note.</li>
 *   <li> EDAMErrorCode.PERMISSION_DENIED "lock" - the service rejected the caller's
 *     request to acquire the lock because either the lock was currently held by
 *     another client, or the caller has held the lock continually for too long.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *    <li> "Note.guid" - note not found</li>
 * </ul>
 */
- (EDAMNoteLockStatus *) acquireNoteLock: (NSString *) authenticationToken noteGuid: (NSString *) noteGuid;

/*
 * This should be called by a client who has previously called acquireNoteLock to
 * indicate that they are done modifying the shared note, and it is available for other
 * clients to lock and edit.
 * 
 * @param noteGuid  the identifier of the note that is being viewed by the client. The
 *    caller must have permission to view that note (e.g. via getNote)
 * 
 * @throws EDAMUserException <ul>
 *   <li> EDAMErrorCode.PERMISSION_DENIED "Note" - if the caller doesn't have permission
 *     to read the indicated note.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *    <li> "Note.guid" - note not found</li>
 * </ul>
 */
- (EDAMNoteLockStatus *) releaseNoteLock: (NSString *) authenticationToken noteGuid: (NSString *) noteGuid;

/*
 * Clients invoke this to request the NoteLockStatus for a set of shared notes within
 * a single account or Business. Clients should never request the note lock viewers
 * for any notes that in private (non-shared) notebooks, or in Business notebooks that
 * are not visible to any other users, since those notes are incapable of having
 * other "viewers."
 * <br/>
 * The response will contain the set of viewers and the lock on each note that has
 * either. If any of the note GUIDs provided by the caller does not correspond to a
 * note with any viewers, then it will be omitted from the response. (This includes
 * any GUIDs for notes that do not exist in the account.) This means that the number
 * of elements in the response will frequently be much lower than the number of GUIDs
 * in the request. The response may even be an empty map if none of the requested GUIDs
 * currently has viewers.
 * <br/>
 * This won't register the caller as a viewer on any of the notes in the list. Unlike
 * getNoteLockStatus, which implicitly registers the caller as a "viewer" of the
 * target note, this is only used to passively determine the set of active viewers
 * for each note on the list.
 * <br/>
 * Callers may only request the status of up to EDAM_NOTE_LOCK_VIEWERS_NOTES_MAX notes
 * in a single call. This is intended to permit a client to find the current viewership
 * of a set of notes within a visible portion of a note list in the client UI. This
 * call should never be used to ask about the viewership of notes that aren't currently
 * listed in the active user interface.
 * <br/>
 * Clients must also actively prevent invocations of this method when the application
 * is not currently active and in use. I.e. an untouched background application must
 * not poll this method.
 * 
 * @param noteGuids  the set of GUIDs in the authenticated account (or authenticated
 *    Business) that should be checked for viewers.
 * 
 * @throws EDAMUserException <ul>
 *   <li> EDAMErrorCode.LIMIT_REACHED "noteGuids" - the caller has requested the set of
 *     viewers for more than EDAM_NOTE_LOCK_VIEWERS_NOTES_MAX notes.
 * </ul>
 */
- (NSDictionary<NSString *,EDAMNoteLockStatus *> *) getViewersForNotes: (NSString *) authenticationToken noteGuids: (NSArray<NSString *> *) noteGuids;

/*
 * Perform the same operation as updateNote() would provided that the update
 * sequence number on the parameter Note object matches the current update sequence
 * number that the service has for the note.  If they do <i>not</i> match, then
 * <i>no</i> update is performed and the return value will have the current server
 * state in the note field and updated will be false.  If the update sequence
 * numbers between the client and server do match, then the note will be updated
 * and the note field of the return value will be returned as it would be for the
 * updateNote method.  This method allows you to check for an update to the note
 * on the service, by another client instance, from when you obtained the
 * note state as a baseline for your edits and the time when you wish to save your
 * edits.  If your client can merge the conflict, you can avoid overwriting changes
 * that were saved to the service by the other client.
 * 
 * See the updateNote method for information on the exceptions and parameters for
 * this method.  The only difference is that you must have an update sequence number
 * defined on the note parameter (equal to the USN of the note as synched to the
 * client), and the following additional exceptions might be thrown.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
 *       not provided.  This includes a value that is set as 0.</li>
 *   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
 *       sequence number that is larger than the current server value, which should
 *       not happen if your client is working correctly.</li>
 * </ul>
 */
- (EDAMUpdateNoteIfUsnMatchesResult *) updateNoteIfUsnMatches: (NSString *) authenticationToken note: (EDAMNote *) note;

/*
 * Manage invitations and memberships associated with a given notebook.
 * 
 * <i>Note:</i> Beta method! This method is currently intended for
 * limited use by Evernote clients that have discussed using this
 * routine with the platform team.
 * 
 * @param parameters A structure containing all parameters for the updates.
 *    See the structure documentation for details.
 * 
 * @throws EDAMUserException <ul>
 *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
 *    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
 *    shares.</li>
 * </ul>
 */
- (EDAMManageNotebookSharesResult *) manageNotebookShares: (NSString *) authenticationToken parameters: (EDAMManageNotebookSharesParameters *) parameters;

/*
 * Return the share relationships for the given notebook, including
 * both the invitations and the memberships.
 * 
 * <i>Note:</i> Beta method! This method is currently intended for
 * limited use by Evernote clients that have discussed using this
 * routine with the platform team.
 */
- (EDAMShareRelationships *) getNotebookShares: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid;

/*
 * Return the share relationships for the given note, including both
 * outstanding invitations and redeemed invitations that have been
 * permanently assigned to a specific Evernote user.
 * 
 * This function returns a higher level representation of a note's sharing
 * status that Note.sharedNotes. It is specifically intended for use in
 * user interfaces for managing a note's shares - updating and removing
 * existing invitations and memberships.
 * 
 * @param authenticationToken
 *   An authentication token that grants the caller access to the specified
 *   note. This should be an owner token if the note is owned by the caller or
 *   shared with the caller via note sharing. If the note is in a business
 *   notebook to which the caller has full access, this should be their business
 *   authentication token. If the note is in a shared (non-business) notebook
 *   to which the caller has full access, this should be the shared notebook
 *   authentication token returned by NoteStore.authenticateToNotebook.
 * 
 * @param noteGuid
 *   The GUID of the note to get the shares for.
 * 
 * @return
 *   The list of shares for the specified note, which will contain no more than
 *   one NoteInvitationShareRelationship per invited identity ID, and no more
 *   that one NoteMemberShareRelationship per recipient user ID.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Note.guid" - If there is no note with the specified GUID.</li>
 * </ul>
 */
- (EDAMNoteShareRelationships *) getNoteShares: (NSString *) authenticationToken noteGuid: (NSString *) noteGuid;

/*
 * Manage existing invitations and memberships for a given note. See getNoteShares.
 * 
 * @parameters
 *   Defines the set of shares that the caller would like to updated or delete.
 * 
 * @return
 *   A structure specifying modifications that failed. See ManageNoteSharesError.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "parameters" - If no ManageNoteSharesParameters was passed.
 *   </li>
 *   <li>DATA_REQUIRED "Note.guid" - If paramaters.noteGuid was not set.</li>
 *   <li>BAD_DATA_FORMAT "Note.guid" - If parameters.noteGuid is not a valid GUID.
 *   </li>
 *   <li>DATA_REQUIRED "NoteMemberShareRelationship.recipientUserId" - If
 *     parameters.membershipsToUpdate includes a NoteMemberShareRelationship with no
 *     recipientUserId set.</li>
 *   <li>DATA_REQUIRED "NoteInvitationShareRelationship.recipientIdentityId" - If
 *     parameters.invitationToUpdate includes a NoteInvitationShareRelationship with no
 *     recipientIdentityId set.</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"Note.guid" - If the note identified by parameters.noteGuid is not found.</li>
 * </ul>
 */
- (EDAMManageNoteSharesResult *) manageNoteShares: (NSString *) authenticationToken parameters: (EDAMManageNoteSharesParameters *) parameters;

/*
 * @deprecated Use setNotebookRecipientSettings instead. This API will be removed in the future.
 */
- (EDAMSharedNotebook *) joinPublishedBusinessNotebook: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid;

/*
 * Unpublish the notebook with the given notebookGuid, either converting
 * GROUP shares to individual shares at the published privilege level or
 * removing all shared notebooks at GROUP privilege level.
 * 
 * <i>Note:</i> This method is currently intended for limited use by
 * Evernote clients that have discussed using this routine with the
 * platform team.
 * 
 * @param authenticationToken
 *   A valid authentication token as used to access the notebook.  Requires
 *   the right to publish the notebook, either business or public, and
 *   permission to update all shared notebook records for the given
 *   notebook.
 * 
 * @param notebookGuid
 *   The GUID of the notebook.
 * 
 * @param convertGroupSharesToIndividual
 *   If true, existing SharedNotebook with Group privilege will be updated
 *   with the privilege that the business notebook has.  If false, all
 *   SharedNotebooks on this notebook will be expunged.  Note that only
 *   business notebooks can have group records, so this parameter is
 *   effectively ignored for public notebooks.
 * 
 * @throws EDAMUserException <ul>
 *   <li>PERMISSION_DENIED "authenticationToken" - the owner or recipient of
 *     this auth token does not have permission to unpublish.</li>
 *   </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li>Notebook.guid - if no notebook is found with the given notebook guid.
 *   </li>
 *   </ul>
 */
- (void) unpublishNotebook: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid convertGroupSharesToIndividual: (BOOL) convertGroupSharesToIndividual;

/*
 * A utility method to be used by clients to sanitize a list of e-mail addresses
 * to a unique set based on an input list of identities.  This method will
 * determine the current e-mail addresses for Evernote UserID identities and
 * will de-duplicate all e-mail addresses in the final list across both memberships
 * and invitations.
 * 
 * Note that this method stands a decent chance of being deprecated in the future.
 * The primary use case for this method is currently to allow a "mailto:" link for
 * clients to use for native sending of e-mail to share recipients.  It is intended
 * for use only by Evernote clients.
 * 
 * @param notebookGuid The GUID of the notebook whose shares are being used to
 *    check for a correct assocation with the notebook and to determine the e-mail
 *    addresses to be used.
 * 
 * @param shareIdentities The identities of the shares from which we calculate the
 *    final list of e-mail addresses.  Note: memberships should be represented by an
 *    Evernote UserID identity type.
 * 
 * @param skipUnknownUserIdentities Whether or not we should silently skip those
 *    entries from identities that are not associated with the notebook or
 *    throw an exception.  If true, we will silently skip those entries, else we
 *    will throw a not-found exception.
 */
- (NSSet<NSString *> *) getNotebookSharesEmailAddresses: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid identities: (NSArray<EDAMUserIdentity *> *) identities skipUnknownUserIdentities: (BOOL) skipUnknownUserIdentities;

/*
 * Rename a specified notebook.
 * 
 * @param notebookGuid
 *   The GUID of the notebook.
 * 
 * @param name
 *   The new name of the notebook.
 * 
 * @return
 *   The Update Sequence Number for this change.
 * 
 * @throws EDAMUserException <ul>
 *   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
 *   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li> "Notebook.guid" - not found, by GUID
 *   </li>
 * </ul>
 */
- (int32_t) renameNotebook: (NSString *) authenticationToken notebookGuid: (NSString *) notebookGuid name: (NSString *) name;

/*
 * Used to send log requests from clients to the server.
 * 
 * @param authenticationToken
 *   Must be a valid token for the user's account.
 * 
 * @param logRequest
 *   The logging information to be sent to the server.
 */
- (EDAMLogResponse *) sendLogRequest: (NSString *) authenticationToken logRequest: (EDAMLogRequest *) logRequest;

/*
 * Asks the NoteStore to provide information about the status of a linked
 * account that has notes shared with the caller.
 * 
 * This function must be called on the shard that owns the referenced
 * LinkedAccount.inAccountUserId  (I.e. the shardId in /shard/shardId/edam/note must
 * be the same as LinkedAccount.inAccountUserId).
 * 
 * @param authenticationToken
 *   This should be an authenticationToken for the guest (their "owner" token).
 * 
 * @param linkedAccount
 *   This structure should contain identifying information, in particular, the
 *   LinkedAccount.inAccountUserId value.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "LinkedAccount.inAccountUserId" - The ID of the user must be
 *       populated with the current user ID that owns the notes shared with the caller.
 *   </li>
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"LinkedNotebook.inAccountUserId" - If the LinkedAccount.inAccountUserId field
 *       does not correspond to a current user on this shard or one which has notes
 *       shared with you.
 *   </li>
 * </ul>
 */
- (EDAMSyncState *) getLinkedAccountSyncState: (NSString *) authenticationToken linkedAccount: (EDAMLinkedAccount *) linkedAccount;

@end

@interface EDAMNoteStoreClient : NSObject <EDAMNoteStore> 
{
  id <ENTProtocol> _inProtocol;
  id <ENTProtocol> _outProtocol;
}
- (instancetype) initWithProtocol: (id <ENTProtocol>) protocol;
- (instancetype) initWithInProtocol: (id <ENTProtocol>) inProtocol outProtocol: (id <ENTProtocol>) outProtocol;
@end

@interface EDAMNoteStoreConstants : NSObject 
@end
