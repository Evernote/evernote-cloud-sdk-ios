/*
 * Copyright (c) 2017 by Evernote Corporation, All rights reserved.
 *
 * Use of the source code and binary libraries included in this package
 * is permitted under the following terms:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "ENTProtocol.h"
#import "ENTException.h"
#import "FATObject.h"
#import "EDAMTypes.h"
#import "EDAMErrors.h"
#import "EDAMAuthenticationTypes.h"

/*
 *  This structure is used to provide publicly-available user information
 *  about a particular account.
 * <dl>
 *  <dt>userId:</dt>
 *    <dd>
 *    The unique numeric user identifier for the user account.
 *    </dd>
 *  <dt>shardId:</dt>
 *    <dd>
 *    DEPRECATED - Client applications should have no need to use this field.
 *    </dd>
 *  <dt>privilege:</dt>
 *    <dd>
 *    DEPRECATED - ServiceLevel field should be used instead to determine which features
 *                 to offer to the user.
 *    </dd>
 *  <dt>serviceLevel:</dt>
 *    <dd>
 *    The service level of the account.
 *    </dd>
 *  <dt>noteStoreUrl:</dt>
 *    <dd>
 *    This field will contain the full URL that clients should use to make
 *    NoteStore requests to the server shard that contains that user's data.
 *    I.e. this is the URL that should be used to create the Thrift HTTP client
 *    transport to send messages to the NoteStore service for the account.
 *    </dd>
 *  <dt>webApiUrlPrefix:</dt>
 *    <dd>
 *    This field will contain the initial part of the URLs that should be used
 *    to make requests to Evernote's thin client "web API", which provide
 *    optimized operations for clients that aren't capable of manipulating
 *    the full contents of accounts via the full Thrift data model. Clients
 *    should concatenate the relative path for the various servlets onto the
 *    end of this string to construct the full URL, as documented on our
 *    developer web site.
 *    </dd>
 *  </dl>
 */
@interface EDAMPublicUserInfo : FATObject 
@property (nonatomic, strong) NSNumber * userId; // EDAMUserID
@property (nonatomic, strong) NSString * shardId;
@property (nonatomic, strong) NSNumber * privilege; // int
@property (nonatomic, strong) NSNumber * serviceLevel; // int
@property (nonatomic, strong) NSString * username;
@property (nonatomic, strong) NSString * noteStoreUrl;
@property (nonatomic, strong) NSString * webApiUrlPrefix;
@end

/*
 * <dl>
 * <dt>noteStoreUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use to make
 *   NoteStore requests to the server shard that contains that user's data.
 *   I.e. this is the URL that should be used to create the Thrift HTTP client
 *   transport to send messages to the NoteStore service for the account.
 *   </dd>
 * <dt>webApiUrlPrefix:</dt>
 *   <dd>
 *   This field will contain the initial part of the URLs that should be used
 *   to make requests to Evernote's thin client "web API", which provide
 *   optimized operations for clients that aren't capable of manipulating
 *   the full contents of accounts via the full Thrift data model. Clients
 *   should concatenate the relative path for the various servlets onto the
 *   end of this string to construct the full URL, as documented on our
 *   developer web site.
 *   </dd>
 * <dt>userStoreUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use to make UserStore
 *   requests after successfully authenticating. I.e. this is the URL that should be used
 *   to create the Thrift HTTP client transport to send messages to the UserStore service
 *   for this account.
 *   </dd>
 * <dt>utilityUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use to make Utility requests
 *   to the server shard that contains that user's data. I.e. this is the URL that should
 *   be used to create the Thrift HTTP client transport to send messages to the Utility
 *   service for the account.
 *   </dd>
 * <dt>messageStoreUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use to make MessageStore
 *   requests to the server. I.e. this is the URL that should be used to create the
 *   Thrift HTTP client transport to send messages to the MessageStore service for the
 *   account.
 *   </dd>
 * <dt>userWebSocketUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use when opening a
 *   persistent web socket to recieve notification of events for the authenticated user.
 *   </dd>
 * <dt>communicationEngineUrl:</dt>
 *   <dd>
 *   This field will contain the full URL that clients should use to make
 *   CommunicationEngine requests to the server.
 *   </dd>
 * </dl>
 */
@interface EDAMUserUrls : FATObject 
@property (nonatomic, strong) NSString * noteStoreUrl;
@property (nonatomic, strong) NSString * webApiUrlPrefix;
@property (nonatomic, strong) NSString * userStoreUrl;
@property (nonatomic, strong) NSString * utilityUrl;
@property (nonatomic, strong) NSString * messageStoreUrl;
@property (nonatomic, strong) NSString * userWebSocketUrl;
@property (nonatomic, strong) NSString * communicationEngineUrl;
@end

/*
 *  When an authentication (or re-authentication) is performed, this structure
 *  provides the result to the client.
 * <dl>
 *  <dt>currentTime:</dt>
 *    <dd>
 *    The server-side date and time when this result was
 *    generated.
 *    </dd>
 *  <dt>authenticationToken:</dt>
 *    <dd>
 *    Holds an opaque, ASCII-encoded token that can be
 *    used by the client to perform actions on a NoteStore.
 *    </dd>
 *  <dt>expiration:</dt>
 *    <dd>
 *    Holds the server-side date and time when the
 *    authentication token will expire.
 *    This time can be compared to "currentTime" to produce an expiration
 *    time that can be reconciled with the client's local clock.
 *    </dd>
 *  <dt>user:</dt>
 *    <dd>
 *    Holds the information about the account which was
 *    authenticated if this was a full authentication.  May be absent if this
 *    particular authentication did not require user information.
 *    </dd>
 *  <dt>publicUserInfo:</dt>
 *    <dd>
 *    If this authentication result was achieved without full permissions to
 *    access the full User structure, this field may be set to give back
 *    a more limited public set of data.
 *    </dd>
 *  <dt>noteStoreUrl:</dt>
 *    <dd>
 *    DEPRECATED - Client applications should use urls.noteStoreUrl.
 *    </dd>
 *  <dt>webApiUrlPrefix:</dt>
 *    <dd>
 *    DEPRECATED - Client applications should use urls.webApiUrlPrefix.
 *    </dd>
 *  <dt>secondFactorRequired:</dt>
 *    <dd>
 *    If set to true, this field indicates that the user has enabled two-factor
 *    authentication and must enter their second factor in order to complete
 *    authentication. In this case the value of authenticationResult will be
 *    a short-lived authentication token that may only be used to make a
 *    subsequent call to completeTwoFactorAuthentication.
 *    </dd>
 *  <dt>secondFactorDeliveryHint:</dt>
 *    <dd>
 *    When secondFactorRequired is set to true, this field may contain a string
 *    describing the second factor delivery method that the user has configured.
 *    This will typically be an obfuscated mobile device number, such as
 *    "(xxx) xxx-x095". This string can be displayed to the user to remind them
 *    how to obtain the required second factor.
 *    </dd>
 *  <dt>urls</dt>
 *    <dd>
 *    This structure will contain all of the URLs that clients need to make requests to the
 *    Evernote service on behalf of the authenticated User.
 *    </dd>
 *  </dl>
 */
@interface EDAMAuthenticationResult : FATObject 
@property (nonatomic, strong) NSNumber * currentTime; // EDAMTimestamp
@property (nonatomic, strong) NSString * authenticationToken;
@property (nonatomic, strong) NSNumber * expiration; // EDAMTimestamp
@property (nonatomic, strong) EDAMUser * user;
@property (nonatomic, strong) EDAMPublicUserInfo * publicUserInfo;
@property (nonatomic, strong) NSString * noteStoreUrl;
@property (nonatomic, strong) NSString * webApiUrlPrefix;
@property (nonatomic, strong) NSNumber * secondFactorRequired; // BOOL
@property (nonatomic, strong) NSString * secondFactorDeliveryHint;
@property (nonatomic, strong) EDAMUserUrls * urls;
@end

/*
 *  This structure describes a collection of bootstrap settings.
 * <dl>
 *  <dt>serviceHost:</dt>
 *    <dd>
 *    The hostname and optional port for composing Evernote web service URLs.
 *    This URL can be used to access the UserStore and related services,
 *    but must not be used to compose the NoteStore URL. Client applications
 *    must handle serviceHost values that include only the hostname
 *    (e.g. www.evernote.com) or both the hostname and port (e.g. www.evernote.com:8080).
 *    If no port is specified, or if port 443 is specified, client applications must
 *    use the scheme "https" when composing URLs. Otherwise, a client must use the
 *    scheme "http".
 *  </dd>
 *  <dt>marketingUrl:</dt>
 *    <dd>
 *    The URL stem for the Evernote corporate marketing website, e.g. http://www.evernote.com.
 *    This stem can be used to compose website URLs. For example, the URL of the Evernote
 *    Trunk is composed by appending "/about/trunk/" to the value of marketingUrl.
 *    </dd>
 *  <dt>supportUrl:</dt>
 *    <dd>
 *    The full URL for the Evernote customer support website, e.g. https://support.evernote.com.
 *    </dd>
 *  <dt>accountEmailDomain:</dt>
 *    <dd>
 *    The domain used for an Evernote user's incoming email address, which allows notes to
 *    be emailed into an account. E.g. m.evernote.com.
 *    </dd>
 *  <dt>cardscanUrl:</dt>
 *    <dd>
 *    The full URL for the business card scanning service, e.g.
 *    https://cscan.evernote.com/cardagain.
 *    </dd>
 *  <dt>announcementsUrl</dt>
 *    <dd>
 *    The base URL for the Announcements service, e.g. https://announce.evernote.com.
 *    </dd>
 *  <dt>enableFacebookSharing:</dt>
 *    <dd>
 *    Whether the client application should enable sharing of notes on Facebook.
 *    </dd>
 *  <dt>enableGiftSubscriptions:</dt>
 *    <dd>
 *    Whether the client application should enable gift subscriptions.
 *    </dd>
 *  <dt>enableSupportTickets:</dt>
 *    <dd>
 *    Whether the client application should enable in-client creation of support tickets.
 *    </dd>
 *  <dt>enableSharedNotebooks:</dt>
 *    <dd>
 *    Whether the client application should enable shared notebooks.
 *    </dd>
 *  <dt>enableSingleNoteSharing:</dt>
 *    <dd>
 *    Whether the client application should enable single note sharing.
 *    </dd>
 *  <dt>enableSponsoredAccounts:</dt>
 *    <dd>
 *    Whether the client application should enable sponsored accounts.
 *    </dd>
 *  <dt>enableTwitterSharing:</dt>
 *    <dd>
 *    Whether the client application should enable sharing of notes on Twitter.
 *    </dd>
 *  <dt>enableGoogle:</dt>
 *    <dd>
 *    Whether the client application should enable authentication with Google,
 *    for example to allow integration with a user's Gmail contacts.
 *  </dl>
 */
@interface EDAMBootstrapSettings : FATObject 
@property (nonatomic, strong) NSString * serviceHost;
@property (nonatomic, strong) NSString * marketingUrl;
@property (nonatomic, strong) NSString * supportUrl;
@property (nonatomic, strong) NSString * accountEmailDomain;
@property (nonatomic, strong) NSString * cardscanUrl;
@property (nonatomic, strong) NSString * announcementsUrl;
@property (nonatomic, strong) NSNumber * enableFacebookSharing; // BOOL
@property (nonatomic, strong) NSNumber * enableGiftSubscriptions; // BOOL
@property (nonatomic, strong) NSNumber * enableSupportTickets; // BOOL
@property (nonatomic, strong) NSNumber * enableSharedNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * enableSingleNoteSharing; // BOOL
@property (nonatomic, strong) NSNumber * enableSponsoredAccounts; // BOOL
@property (nonatomic, strong) NSNumber * enableTwitterSharing; // BOOL
@property (nonatomic, strong) NSNumber * enableLinkedInSharing; // BOOL
@property (nonatomic, strong) NSNumber * enablePublicNotebooks; // BOOL
@property (nonatomic, strong) NSNumber * enableGoogle; // BOOL
@end

/*
 *  This structure describes a collection of bootstrap settings.
 * <dl>
 *  <dt>name:</dt>
 *    <dd>
 *    The unique name of the profile, which is guaranteed to remain consistent across
 *    calls to getBootstrapInfo.
 *    </dd>
 *  <dt>settings:</dt>
 *    <dd>
 *    The settings for this profile.
 *    </dd>
 *  </dl>
 */
@interface EDAMBootstrapProfile : FATObject 
@property (nonatomic, strong) NSString * name;
@property (nonatomic, strong) EDAMBootstrapSettings * settings;
@end

/*
 *  This structure describes a collection of bootstrap profiles.
 * <dl>
 *  <dt>profiles:</dt>
 *    <dd>
 *    List of one or more bootstrap profiles, in descending
 *    preference order.
 *    </dd>
 *  </dl>
 */
@interface EDAMBootstrapInfo : FATObject 
@property (nonatomic, strong) NSArray<EDAMBootstrapProfile *> * profiles;
@end

/*
 * This structure contains credentials that can be used by the service to send a push
 * notification to a client application. It is used by a client to share the appropriate
 * credentials with the service so that the service can later send notifications back
 * to the client. A client must fill in only those fields that are relevant for the
 * platform:
 * 
 * <ul>
 * <li>iOS applications must fill in the iosDeviceToken field and must leave any other
 * fields unset.</li>
 * <li>Android applications must fill in the gcmRegistrationId field and must leave any
 * other fields unset.</li>
 * </ul>
 * 
 * <dl>
 *   <dt>iosDeviceToken:</dt>
 *   <dd>An iOS device token. Must be exactly 32 bytes in length.
 *   <dt>gcmRegistrationId:</dt>
 *   <dd>An Android GCM registration id. The length is not fixed but cannot exceed 4k.
 * </dl>
 */
@interface EDAMPushNotificationCredentials : FATObject 
@property (nonatomic, strong) NSData * iosDeviceToken;
@property (nonatomic, strong) NSString * gcmRegistrationId;
@end

/*
 * This structure is returned from the service when clients register for push notifications.
 * It contains information clients may need in order to process future push notifications.
 * 
 * <dl>
 *   <dt>sharedSecret:</dt>
 *   <dd>
 *   Secret key used to decrypt notification payloads. Clients should treat this
 *   as an opaue value and make no particular assumptions about its format or source.
 *   </dd>
 * </dl>
 */
@interface EDAMRegisterForSyncPushNotificationsResult : FATObject 
@property (nonatomic, strong) NSData * sharedSecret;
@end

/*
 * This structure is passed to authenticateLongSessionV2 to create a long-lived
 * authentication token that can be used for further actions.
 * 
 * This struct is marked as internal until we release business-only accounts.
 * 
 * <dl>
 *   <dt>usernameOrEmail<dt>
 *   <dd>
 *   The username or registered email address of the account to authenticate against. This
 *   field is required.
 *   </dd>
 *   <dt>password<dt>
 *   <dd>
 *   The plaintext password to check against the account. Since this is not protected by
 *   the EDAM protocol, this information must be provided over a protected transport
 *   (i.e. SSL). This field is required, unless the account is a business-only account
 *   with SSO enabled, in which case ssoLoginToken must be passed instead.
 *   </dd>
 *   <dt>ssoLoginToken<dt>
 *   <dd>
 *   The plaintext SSO login token to check against the account. This must be provided in
 *   lieu of a password if the account is a business-only account with SSO enabled.
 *   </dd>
 *   <dt>consumerKey<dt>
 *   <dd>
 *   The "consumer key" portion of the API key issued to the client application by
 *   Evernote.
 *   </dd>
 *   <dt>consumerSecret<dt>
 *   <dd>
 *   The "consumer secret" portion of the API key issued to the client application by
 *   Evernote.
 *   </dd>
 *   <dt>deviceIdentifier</dt>
 *   <dd>
 *   An optional string that uniquely identifies the device from which the authentication
 *   is being performed. This string allows the service to return the same authentication
 *   token when a given application requests authentication repeatedly from the same
 *   device. This may happen when the user logs out of an application and then logs back
 *   in, or when the application is uninstalled and later reinstalled. If no reliable
 *   device identifier can be created, this value should be omitted. If set, the device
 *   identifier must be between 1 and EDAM_DEVICE_ID_LEN_MAX characters long and must
 *   match the regular expression EDAM_DEVICE_ID_REGEX.
 *   </dd>
 *   <dt>deviceDescription</dt>
 *   <dd>
 *   A description of the device from which the authentication is being performed. This
 *   field is displayed to the user in a list of authorized applications to allow them to
 *   distinguish between multiple tokens issued to the same client application on
 *   different devices. For example, the Evernote iOS client on a user's iPhone and iPad
 *   might pass the iOS device names "Bob's iPhone" and "Bob's iPad". The device
 *   description must be between 1 and EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and
 *   must match the regular expression EDAM_DEVICE_DESCRIPTION_REGEX.
 *   </dd>
 *   <dt>supportsTwoFactor</dt>
 *   <dd>
 *   Whether the calling application supports two-factor authentication. If this parameter
 *   is false, this method will fail with the error code INVALID_AUTH and the parameter
 *   "password" when called for a user who has enabled two-factor authentication.
 *   </dd>
 * </dl>
 */
@interface EDAMAuthenticationParameters : FATObject 
@property (nonatomic, strong) NSString * usernameOrEmail;
@property (nonatomic, strong) NSString * password;
@property (nonatomic, strong) NSString * ssoLoginToken;
@property (nonatomic, strong) NSString * consumerKey;
@property (nonatomic, strong) NSString * consumerSecret;
@property (nonatomic, strong) NSString * deviceIdentifier;
@property (nonatomic, strong) NSString * deviceDescription;
@property (nonatomic, strong) NSNumber * supportsTwoFactor; // BOOL
@property (nonatomic, strong) NSNumber * supportsBusinessOnlyAccounts; // BOOL
@end

@protocol EDAMUserStore <NSObject>
/*
 * This should be the first call made by a client to the EDAM service.  It
 * tells the service what protocol version is used by the client.  The
 * service will then return true if the client is capable of talking to
 * the service, and false if the client's protocol version is incompatible
 * with the service, so the client must upgrade.  If a client receives a
 * false value, it should report the incompatibility to the user and not
 * continue with any more EDAM requests (UserStore or NoteStore).
 * 
 * @param clientName
 *   This string provides some information about the client for
 *   tracking/logging on the service.  It should provide information about
 *   the client's software and platform. The structure should be:
 *   application/version; platform/version; [ device/version ]
 *   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
 * 
 * @param edamVersionMajor
 *   This should be the major protocol version that was compiled by the
 *   client.  This should be the current value of the EDAM_VERSION_MAJOR
 *   constant for the client.
 * 
 * @param edamVersionMinor
 *   This should be the major protocol version that was compiled by the
 *   client.  This should be the current value of the EDAM_VERSION_MINOR
 *   constant for the client.
 */
- (BOOL) checkVersion: (NSString *) clientName edamVersionMajor: (int16_t) edamVersionMajor edamVersionMinor: (int16_t) edamVersionMinor;

/*
 * This provides bootstrap information to the client. Various bootstrap
 * profiles and settings may be used by the client to configure itself.
 * 
 * @param locale
 *   The client's current locale, expressed in language[_country]
 *   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
 *   language and country codes.
 * 
 * @return
 *   The bootstrap information suitable for this client.
 */
- (EDAMBootstrapInfo *) getBootstrapInfo: (NSString *) locale;

/*
 * This is used to check a username and password in order to create a
 * short-lived authentication session that can be used for further actions.
 * 
 * This function is only available to Evernote's internal applications.
 * Third party applications must authenticate using OAuth as
 * described at
 * <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
 * 
 * @param username
 *   The username (not numeric user ID) for the account to
 *   authenticate against.  This function will also accept the user's
 *   registered email address in this parameter.
 * 
 * @param password
 *   The plaintext password to check against the account.  Since
 *   this is not protected by the EDAM protocol, this information must be
 *   provided over a protected transport (e.g. SSL).
 * 
 * @param consumerKey
 *   The "consumer key" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param consumerSecret
 *   The "consumer secret" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param supportsTwoFactor
 *   Whether the calling application supports two-factor authentication. If this
 *   parameter is false, this method will fail with the error code INVALID_AUTH and the
 *   parameter "password" when called for a user who has enabled two-factor
 *   authentication.
 * 
 * @return
 *   <p>The result of the authentication.  If the authentication was successful,
 *   the AuthenticationResult.user field will be set with the full information
 *   about the User.</p>
 *   <p>If the user has two-factor authentication enabled,
 *   AuthenticationResult.secondFactorRequired will be set and
 *   AuthenticationResult.authenticationToken will contain a short-lived token
 *   that may only be used to complete the two-factor authentication process by calling
 *   UserStore.completeTwoFactorAuthentication.</p>
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "username" - username is empty
 *   <li> DATA_REQUIRED "password" - password is empty
 *   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
 *   <li> INVALID_AUTH "username" - username not found
 *   <li> INVALID_AUTH "password" - password did not match
 *   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
 *   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
 *   <li> PERMISSION_DENIED "User.active" - user account is closed
 *   <li> PERMISSION_DENIED "businessUserStatus" - business user account is not active
 *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
 *     failed authentication too often
 *   <li> AUTH_EXPIRED "password" - user password is expired
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticate: (NSString *) username password: (NSString *) password consumerKey: (NSString *) consumerKey consumerSecret: (NSString *) consumerSecret supportsTwoFactor: (BOOL) supportsTwoFactor;

/*
 * This method is used to authenticate a user using user's Open ID to create a
 * authentication session that can be used for further actions.
 * 
 * This function is only available to Evernote's internal applications.
 * Third party applications must authenticate using OAuth as
 * described at
 * <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
 * 
 * @param OpenIdCredential
 *   Token Payload and Open ID service provider for the user to authenticate with. This method is
 *   expected to be called after user has successfully completed the Authentication flow with
 *   OpenID service provider.
 * 
 * @param consumerKey
 *   The "consumer key" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param consumerSecret
 *   The "consumer secret" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param supportsTwoFactor
 *   Whether the calling application supports two-factor authentication. If this
 *   parameter is false, this method will fail with the error code INVALID_AUTH and the
 *   parameter "password" when called for a user who has enabled two-factor
 *   authentication.
 * 
 * @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
 * 
 * @param deviceDescription See the corresponding parameter in authenticateLongSession.
 * 
 * @param authLongSession boolean indicating whether a long session is being authenticated.
 * 
 * @param supportsTwoFactor boolean indicating whether two factor authentication is supported.
 * 
 * @return
 *   <p>The result of the authentication.  If the authentication was successful,
 *   the AuthenticationResult.user field will be set with the full information
 *   about the User.</p>
 *   <p>If the user has two-factor authentication enabled,
 *   AuthenticationResult.secondFactorRequired will be set and
 *   AuthenticationResult.authenticationToken will contain a short-lived token
 *   that may only be used to complete the two-factor authentication process by calling
 *   UserStore.completeTwoFactorAuthentication.</p>
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "OpenIdCredential.tokenPayload" - tokenPayload is empty
 *   <li> DATA_REQUIRED "OpenIdCredential.serviceProvider" - serviceProvider is empty
 *   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
 *   <li> INVALID_AUTH "tokenPayload" - username not found
 *   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
 *   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
 *   <li> PERMISSION_DENIED "User.active" - user account is closed
 *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
 *     failed authentication too often
 *   <li> AUTH_EXPIRED "password" - user password is expired
 * </ul>
 * @throws EDAMSystemException <ul>
 *   <li> BAD_DATA_FORMAT "OpenIdCredential.tokenPayload" - open id invalid token format
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateOpenID: (EDAMOpenIdCredential *) credential consumerKey: (NSString *) consumerKey consumerSecret: (NSString *) consumerSecret deviceIdentifier: (NSString *) deviceIdentifier deviceDescription: (NSString *) deviceDescription authLongSession: (BOOL) authLongSession supportsTwoFactor: (BOOL) supportsTwoFactor;

/*
 * This is used to check a username and password in order to create a
 * long-lived authentication token that can be used for further actions.
 * 
 * This function is not available to most third party applications,
 * which typically authenticate using OAuth as
 * described at
 * <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
 * If you believe that your application requires permission to authenticate
 * using username and password instead of OAuth, please contact Evernote
 * developer support by visiting
 * <a href="http://dev.evernote.com">dev.evernote.com</a>.
 * 
 * @param username
 *   The username or registered email address of the account to
 *   authenticate against.
 * 
 * @param password
 *   The plaintext password to check against the account.  Since
 *   this is not protected by the EDAM protocol, this information must be
 *   provided over a protected transport (i.e. SSL).
 * 
 * @param consumerKey
 *   The "consumer key" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param consumerSecret
 *   The "consumer secret" portion of the API key issued to the client application
 *   by Evernote.
 * 
 * @param deviceIdentifier
 *   An optional string that uniquely identifies the device from which the
 *   authentication is being performed. This string allows the service to return the
 *   same authentication token when a given application requests authentication
 *   repeatedly from the same device. This may happen when the user logs out of an
 *   application and then logs back in, or when the application is uninstalled
 *   and later reinstalled. If no reliable device identifier can be created,
 *   this value should be omitted. If set, the device identifier must be between
 *   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
 *   EDAM_DEVICE_ID_REGEX.
 * 
 * @param deviceDescription
 *   A description of the device from which the authentication is being performed.
 *   This field is displayed to the user in a list of authorized applications to
 *   allow them to distinguish between multiple tokens issued to the same client
 *   application on different devices. For example, the Evernote iOS client on
 *   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
 *   "Bob's iPad". The device description must be between 1 and
 *   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
 *   expression EDAM_DEVICE_DESCRIPTION_REGEX.
 * 
 * @param supportsTwoFactor
 *   Whether the calling application supports two-factor authentication. If this
 *   parameter is false, this method will fail with the error code INVALID_AUTH and the
 *   parameter "password" when called for a user who has enabled two-factor
 *   authentication.
 * 
 * @return
 *   <p>The result of the authentication. The level of detail provided in the returned
 *   AuthenticationResult.User structure depends on the access level granted by
 *   calling application's API key.</p>
 *   <p>If the user has two-factor authentication enabled,
 *   AuthenticationResult.secondFactorRequired will be set and
 *   AuthenticationResult.authenticationToken will contain a short-lived token
 *   that may only be used to complete the two-factor authentication process by calling
 *   UserStore.completeTwoFactorAuthentication.</p>
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "username" - username is empty
 *   <li> DATA_REQUIRED "password" - password is empty
 *   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
 *   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
 *   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
 *   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
 *   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
 *   <li> INVALID_AUTH "username" - username not found
 *   <li> INVALID_AUTH "password" - password did not match
 *   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
 *   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
 *   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
 *   <li> PERMISSION_DENIED "User.active" - user account is closed
 *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
 *     failed authentication too often
 *   <li> AUTH_EXPIRED "password" - user password is expired
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateLongSession: (NSString *) username password: (NSString *) password consumerKey: (NSString *) consumerKey consumerSecret: (NSString *) consumerSecret deviceIdentifier: (NSString *) deviceIdentifier deviceDescription: (NSString *) deviceDescription supportsTwoFactor: (BOOL) supportsTwoFactor;

/*
 * This is used to check a username and password in order to create a long-lived
 * authentication token that can be used for further actions.
 * 
 * This function is not available to most third party applications,
 * which typically authenticate using OAuth as described at
 * <a href="https://dev.evernote.com/doc/">dev.evernote.com</a>.
 * If you believe that your application requires permission to authenticate
 * using username and password instead of OAuth, please contact Evernote
 * developer support by visiting
 * <a href="https://dev.evernote.com">dev.evernote.com</a>.
 * 
 * This method is marked as internal until we release business-only accounts.
 * 
 * @param authParams
 *   See documentation for AuthenticationParameters
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "username" - AuthenticationParameters#usernameOrEmail is empty
 *   <li>DATA_REQUIRED "password" - AuthenticationParameters#password is empty
 *   <li>DATA_REQUIRED "consumerKey" - AuthenticationParameters#consumerKey is empty
 *   <li>DATA_REQUIRED "consumerSecret" - AuthenticationParameters#consumerSecret is
 *     empty
 *   <li>DATA_REQUIRED "deviceDescription" - AuthenticationParameters#deviceDescription
 *     is empty
 *   <li>BAD_DATA_FORMAT "deviceDescription" - AuthenticationParameters#deviceDescription
 *     is not valid
 *   <li>BAD_DATA_FORMAT "deviceIdentifier" - AuthenticationParameters#deviceIdentifier
 *     is not valid
 *   <li>INVALID_AUTH "username" - AuthenticationParameters#usernameOrEmail not found
 *   <li>INVALID_AUTH "password" - AuthenticationParameters#password did not match
 *   <li>INVALID_AUTH "consumerKey" - AuthenticationParameters#consumerKey is not
 *     authorized
 *   <li>INVALID_AUTH "consumerSecret" - AuthenticationParameters#consumerSecret is
 *     incorrect
 *   <li>PERMISSION_DENIED "businessUserStatus" - business user account is not active
 *   <li>PERMISSION_DENIED "User.active" - user account is closed
 *   <li>PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has failed
 *     authentication too often
 *   <li>AUTH_EXPIRED "password" - user password is expired
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateLongSessionV2: (EDAMAuthenticationParameters *) authParams;

/*
 * Complete the authentication process when a second factor is required. This
 * call is made after a successful call to authenticate or authenticateLongSession
 * when the authenticating user has enabled two-factor authentication.
 * 
 * @param authenticationToken An authentication token returned by a previous
 *   call to UserStore.authenticate or UserStore.authenticateLongSession that
 *   could not be completed in a single call because a second factor was required.
 * 
 * @param oneTimeCode The one time code entered by the user. This value is delivered
 *   out-of-band, typically via SMS or an authenticator application.
 * 
 * @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
 * 
 * @param deviceDescription See the corresponding parameter in authenticateLongSession.
 * 
 * @return
 *   The result of the authentication. The level of detail provided in the returned
 *   AuthenticationResult.User structure depends on the access level granted by the
 *   calling application's API key. If the initial authentication call was made to
 *   authenticateLongSession, the AuthenticationResult will contain a long-lived
 *   authentication token.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
 *   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
 *   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
 *   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
 *   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
 *   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
 *   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
 *   <li> PERMISSION_DENIED "User.active" - user account is closed
 *   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
 *     failed authentication too often
 *   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
 *      two-factor authentication.</li>
 * </ul>
 */
- (EDAMAuthenticationResult *) completeTwoFactorAuthentication: (NSString *) authenticationToken oneTimeCode: (NSString *) oneTimeCode deviceIdentifier: (NSString *) deviceIdentifier deviceDescription: (NSString *) deviceDescription;

/*
 * Revoke an existing long lived authentication token. This can be used to
 * revoke OAuth tokens or tokens created by calling authenticateLongSession,
 * and allows a user to effectively log out of Evernote from the perspective
 * of the application that holds the token. The authentication token that is
 * passed is immediately revoked and may not be used to call any authenticated
 * EDAM function.
 * 
 * @param authenticationToken the authentication token to revoke.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
 *   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
 *   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
 *   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
 *     is already revoked.
 * </ul>
 */
- (void) revokeLongSession: (NSString *) authenticationToken;

/*
 * This is used to take an existing authentication token that grants access
 * to an individual user account (returned from 'authenticate',
 * 'authenticateLongSession' or an OAuth authorization) and obtain an additional
 * authentication token that may be used to access business notebooks if the user
 * is a member of an Evernote Business account.
 * 
 * The resulting authentication token may be used to make NoteStore API calls
 * against the business using the NoteStore URL returned in the result.
 * 
 * @param authenticationToken
 *   The authentication token for the user. This may not be a shared authentication
 *   token (returned by NoteStore.authenticateToSharedNotebook or
 *   NoteStore.authenticateToSharedNote) or a business authentication token.
 * 
 * @return
 *   The result of the authentication, with the token granting access to the
 *   business in the result's 'authenticationToken' field. The URL that must
 *   be used to access the business account NoteStore will be returned in the
 *   result's 'noteStoreUrl' field.  The 'User' field will
 *   not be set in the result.
 * 
 * @throws EDAMUserException <ul>
 *   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
 *        is a shared or business authentication token. </li>
 *   <li> PERMISSION_DENIED "Business" - the user identified by the provided
 *        authentication token is not currently a member of a business. </li>
 *   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
 *        member of is not currently in an active status. </li>
 *   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
 *        sign-on before authenticating to the business.
 * </ul>
 */
- (EDAMAuthenticationResult *) authenticateToBusiness: (NSString *) authenticationToken;

/*
 * This is used to take an existing authentication token (returned from
 * 'authenticate') and exchange it for a newer token which will not expire
 * as soon.  This must be invoked before the previous token expires.
 * 
 * This function is only availabe to Evernote's internal applications.
 * 
 * @param authenticationToken
 *   The previous authentication token from the authenticate() result.
 * 
 * @return
 *   The result of the authentication, with the new token in
 *   the result's 'authenticationToken' field.  The 'User' field will
 *   not be set in the result.
 */
- (EDAMAuthenticationResult *) refreshAuthentication: (NSString *) authenticationToken;

/*
 * Returns the User corresponding to the provided authentication token,
 * or throws an exception if this token is not valid.
 * The level of detail provided in the returned User structure depends on
 * the access level granted by the token, so a web service client may receive
 * fewer fields than an integrated desktop client.
 */
- (EDAMUser *) getUser: (NSString *) authenticationToken;

/*
 * Asks the UserStore about the publicly available location information for
 * a particular username.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "username" - username is empty
 * </ul>
 */
- (EDAMPublicUserInfo *) getPublicUserInfo: (NSString *) username;

/*
 * Returns information regarding a user's Premium account corresponding to the
 * provided authentication token, or throws an exception if this token is not
 * valid.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 */
- (EDAMPremiumInfo *) getPremiumInfo: (NSString *) authenticationToken;

/*
 * Returns information regarding a user's subscription corresponding to the
 * provided authentication token, or throws an exception if this token is not
 * valid.
 * <p/>
 * NOTE: This function is generally not available to third party applications.
 * Calls will result in an EDAMUserException with the error code
 * PERMISSION_DENIED.
 */
- (EDAMSubscriptionInfo *) getSubscriptionInfo: (NSString *) authenticationToken;

/*
 * DEPRECATED - Use UserStore#getUserUrls() instead.
 */
- (NSString *) getNoteStoreUrl: (NSString *) authenticationToken;

/*
 * <p>Returns the URLs that should be used when sending requests to the service on
 * behalf of the account represented by the provided authenticationToken.</p>
 * 
 * <p>This method isn't needed by most clients, who can retreive the correct set of
 * UserUrls from the AuthenticationResult returned from
 * UserStore#authenticateLongSession(). This method is typically only needed to look up
 * the correct URLs for an existing long-lived authentication token.</p>
 */
- (EDAMUserUrls *) getUserUrls: (NSString *) authenticationToken;

/*
 * Invite a user to join an Evernote Business account.
 * 
 * Behavior will depend on the auth token. <ol>
 *   <li>
 *     auth token with privileges to manage Evernote Business membership.
 *       "External Provisioning" - The user will receive an email inviting
 *       them to join the business. They do not need to have an existing Evernote
 *       account. If the user has already been invited, a new invitation email
 *       will be sent.
 *   </li>
 *   <li>
 *     business auth token issued to an admin user. Only for first-party clients:
 *       "Approve Invitation" - If there has been a request to invite the email,
 *       approve it. Invited user will receive email with a link to join business.
 *       "Invite User" - If no invitation for the email exists, create an approved
 *       invitation for the email. An email will be sent to the emailAddress with
 *       a link to join the caller's business.
 *   </li>
 *   </li>
 *     business auth token:
 *       "Request Invitation" - If no invitation exists, create a request to
 *       invite the user to the business. These requests do not count towards a
 *       business' max active user limit.
 *   </li>
 * </ol>
 * 
 * @param authenticationToken
 *   the authentication token with sufficient privileges to manage Evernote Business
 *   membership or a business auth token.
 * 
 * @param emailAddress
 *   the email address of the user to invite to join the Evernote Business account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "email" - if no email address was provided </li>
 *   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
 *   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
 *     whose business email address matches the specified email address. </li>
 *   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
 *     user limit. </li>
 * </ul>
 */
- (void) inviteToBusiness: (NSString *) authenticationToken emailAddress: (NSString *) emailAddress;

/*
 * Remove a user from an Evernote Business account. Once removed, the user will no
 * longer be able to access content within the Evernote Business account.
 * 
 * <p>The email address of the user to remove from the business must match the email
 * address used to invite a user to join the business via UserStore.inviteToBusiness.
 * This function will only remove users who were invited by external provisioning</p>
 * 
 * @param authenticationToken
 *   An authentication token with sufficient privileges to manage Evernote Business
 *   membership.
 * 
 * @param emailAddress
 *   The email address of the user to remove from the Evernote Business account.
 * 
 * @throws EDAMUserException <ul>
 *   <li> DATA_REQUIRED "email" - if no email address was provided </li>
 *   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
 * </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li> "email" - If there is no user with the specified email address in the
 *     business or that user was not invited via external provisioning. </li>
 * </ul>
 */
- (void) removeFromBusiness: (NSString *) authenticationToken emailAddress: (NSString *) emailAddress;

/*
 * Update the email address used to uniquely identify an Evernote Business user.
 * 
 * This will update the identifier for a user who was previously invited using
 * inviteToBusiness, ensuring that caller and the Evernote service maintain an
 * agreed-upon identifier for a specific user.
 * 
 * For example, the following sequence of calls would invite a user to join
 * a business, update their email address, and then remove the user
 * from the business using the updated email address.
 * 
 * inviteToBusiness("foo@bar.com")
 * updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
 * removeFromBusiness("baz@bar.com")
 * 
 * @param authenticationToken
 *   An authentication token with sufficient privileges to manage Evernote Business
 *   membership.
 * 
 * @param oldEmailAddress
 *   The existing email address used to uniquely identify the user.
 * 
 * @param newEmailAddress
 *   The new email address used to uniquely identify the user.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
 *   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
 *   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
 *   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
 *   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
 *   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
 *     the provided new email address.</li>
 *   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
 *     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
 *     updated.</li>
 * </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
 *     in the business.</li>
 * </ul>
 */
- (void) updateBusinessUserIdentifier: (NSString *) authenticationToken oldEmailAddress: (NSString *) oldEmailAddress newEmailAddress: (NSString *) newEmailAddress;

/*
 * Returns a list of active business users in a given business.
 * 
 * Clients are required to cache this information and re-fetch no more than once per day
 * or when they encountered a user ID or username that was not known to them.
 * 
 * To avoid excessive look ups, clients should also track user IDs and usernames that belong
 * to users who are not in the business, since they will not be included in the result.
 * 
 * I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
 * listBusinessUsers to find information about this user. If the user is not in the resulting
 * list, the client should track that fact and not re-query the service the next time that it sees
 * this user on a note.
 * 
 * @param authenticationToken
 *   A business authentication token returned by authenticateToBusiness or with sufficient
 *   privileges to manage Evernote Business membership.
 */
- (NSArray<EDAMUserProfile *> *) listBusinessUsers: (NSString *) authenticationToken;

/*
 * Returns a list of outstanding invitations to join an Evernote Business account.
 * 
 * Only outstanding invitations are returned by this function. Users who have accepted an
 * invitation and joined a business are listed using listBusinessUsers.
 * 
 * @param authenticationToken
 *   An authentication token with sufficient privileges to manage Evernote Business membership.
 * 
 * @param includeRequestedInvitations
 *   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
 *   in the returned list. If false, only invitations with a status of
 *   BusinessInvitationStatus.APPROVED will be included.
 */
- (NSArray<EDAMBusinessInvitation *> *) listBusinessInvitations: (NSString *) authenticationToken includeRequestedInvitations: (BOOL) includeRequestedInvitations;

/*
 * Register a synchronizing client application to receive push notifications when the
 * sync state of the user's Evernote account changes.
 * <p>
 * When the update_count in an account changes, the Evernote service will send
 * a push notification to each registered application. For performance reasons, the
 * service batches changes made during a short period of time into a single
 * notification, so there is a delay between a change being made and a notification
 * being sent.
 * </p>
 * <p>
 * The exact format of the push notification varies based on the target platform, but
 * all push notifications specify the current update_count for the account. This allows
 * the client application to skip synchronization if it has already sync'd the changes.
 * </p>
 * 
 * @param authenticationToken
 *   A valid owner authentication token associated with an application for which the
 *   Evernote service is capable of sending push notifications.
 * 
 * @param credentials
 *   Contains the credentials that should be used by the service to identify the
 *   recipient device when sending a push notification. For iOS applications, the
 *   32-byte binary deviceToken field must be filled in. For Android applications, the
 *   gcmRegistrationId field must be filled in.
 * 
 * @return A structure containing information clients may need in order to process future
 *   push notifications.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_CONFLICT "authenticationToken" - The service does not know how to send
 *     push notifications for the application associated with the authentication token.
 *   <li>DATA_REQUIRED "credentials" - No credentials were provided.
 *   <li>DATA_REQUIRED "credentials.deviceToken" - No device token was provided.
 *   <li>DATA_CONFLICT "credentials.identifier" - More than one device identifier was provided.
 *   <li>BAD_DATA_FORMAT "credentials.gcmRegistrationId" - The GCM registration id is the incorrect
 *     length.
 *   <li>BAD_DATA_FORMAT "credentials.deviceToken" - The device token is the incorrect
 *     length.
 * </ul>
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"authenticationToken" - The provided authentication token was not obtained via
 *     UserStore.authenticateLongSession.
 * </ul>
 */
- (EDAMRegisterForSyncPushNotificationsResult *) registerForSyncPushNotifications: (NSString *) authenticationToken credentials: (EDAMPushNotificationCredentials *) credentials;

/*
 * Unregister a client application that has previously registered to receive push
 * notifications when the sync state of a user's Evernote account changes. Note that
 * it is not necessary to call this function when a user logs out of the client
 * application, since the client calls revokeLongSession during the logout. Revoking
 * an authentication token automatically unregisters the corresponding client
 * application from push notifications.
 * 
 * @param authenticationToken
 *   A valid owner authentication token that was previously used to call
 *   registerForSyncPushNotifications.
 * 
 * @throws EDAMNotFoundException <ul>
 *   <li>"authenticationToken" - The provided authentication token was not obtained via
 *     UserStore.authenticateLongSession.
 * </ul>
 */
- (void) unregisterForSyncPushNotifications: (NSString *) authenticationToken;

/*
 * Create a new short-lived authentication token based on an existing, valid
 * authentication token.
 * 
 * @param authenticationToken A valid, unexpired, unrevoked owner authentication token.
 *   This token must belong to an Evernote client.
 * 
 * @return A new short-lived (typically 1-hour) authentication token. The new token's
 *   permissions will be the same as the authenticationToken provided. The new token can
 *   not be refreshed.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "authenticationToken" - authenticationToken is null or empty</li>
 *   <li>BAD_DATA_FORMAT "authenticationToken" - authenticationToken is malformed</li>
 *   <li>AUTH_EXPIRED "authenticationToken" - authenticationToken is expired or
 *       revoked</li>
 *   <li>PERMISSION_DENIED "authenticationToken" - authenticationToken is a shared or
 *       business token or it is not a long-lived token.</li>
 * </ul>
 * @throws EDAMSystemException <ul>
 *   <li>INVALID_AUTH "authenticationToken" - authenticationToken has an invalid
 *       signature</li>
 *   <li>INTERNAL_ERROR "authenticationToken" - an internal error occurred validating
 *       authenticationToken</li>
 * </ul>
 * @throws EDAMNotFoundException <ul>
 *   <li> "User.id" - User not found, by ID</li>
 * </ul>
 */
- (NSString *) createSessionAuthenticationToken: (NSString *) authenticationToken;

/*
 * Retrieve the standard account limits for a given service level. This should only be
 * called when necessary, e.g. to determine if a higher level is available should the
 * user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
 * not expected to fluctuate frequently.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
 * </ul>
 */
- (EDAMAccountLimits *) getAccountLimits: (int) serviceLevel;

/*
 * Get the list of Identity instances provided that there is a connection in place
 * for the provided identityIds. If there are no explicit connections and implicit
 * connections (based on evernote business membership), those identityIds will be
 * ignored.
 * 
 * @param identityIds the IDs to retrieve Identities for.
 * 
 * @throws EDAMUserException <ul>
 *   <li>DATA_REQUIRED, "identityIds" if there were no identityIds provided.</li>
 *   <li>TOO_MANY, "identityIds" if more than than
 *     EDAM_CONNECTED_IDENTITY_REQUEST_MAX identityIds were provided.</li>
 * </ul>
 */
- (NSDictionary<NSNumber *,EDAMIdentity *> *) getConnectedIdentities: (NSString *) authenticationToken identityIds: (NSArray<NSNumber *> *) identityIds;

@end

@interface EDAMUserStoreClient : NSObject <EDAMUserStore> 
{
  id <ENTProtocol> _inProtocol;
  id <ENTProtocol> _outProtocol;
}
- (instancetype) initWithProtocol: (id <ENTProtocol>) protocol;
- (instancetype) initWithInProtocol: (id <ENTProtocol>) inProtocol outProtocol: (id <ENTProtocol>) outProtocol;
@end

@interface EDAMUserStoreConstants : NSObject 
+ (int16_t) EDAM_VERSION_MAJOR;
+ (int16_t) EDAM_VERSION_MINOR;
@end
